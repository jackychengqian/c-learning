**要点**

**只关心返回值**

# 有多个重复片段可以利用函数或lambda减少代码重复

# 各种排序!!!!!!!!!!!!!!!!!!!!!!!!!

# 拓扑排序

# 每一题用最优解思考但也要会非最优解

# 48 65 97 ASCLL 0 A a

# 字符转整数 加减法

# 注意边界条件 如空数组  全不满足 等等





# 复习每题时间复杂度  适当背题

# 不要脑袋空想  打草稿更快

#  acm模式  listnode都要自己写 	

# 写复杂的题写注释才好写  复杂题先想想题目可以用什么方法 想好在写 一般题目不会直接暴力求



a+b=c -> a=c-b

寻找是否存在 用哈希表

ip地址

**写完代码检查一下是否能缩减**

字符串操作大全

字符转整数

字符串分割

c++和c方法

# 手撕  池组件  智能指针  stl容器等  网络编程  锁 各种锁乐观读写等  运算符重载  设计模式  lambda 大小根堆 排序



注意lambda两种递归形式：

```cpp
function<void(int,int)> dfs = [&](int i,int j){}   //使用function定义的lambda表达式在{}内可以调用自己实现递归
												   //function将lambda表达式装进去
```



```cpp
auto dfs = [&](auto&& dfs, int i, int j) -> void {}  //使用auto定义必须在形参中加入自身才能在{}调用自己实现递归
```

**`std::function` 和 `auto` 的区别**

- **`std::function`**：是一种通用的、类型安全的函数包装器，允许将各种可调用对象（如普通函数、lambda、函数对象等）赋值给它。`std::function` 可以持有自身的引用，这使得它支持递归定义。
- **`auto`**：在声明 lambda 表达式时，用 `auto` 推导 lambda 的具体类型。然而，lambda 表达式本身不是一个真正的类型（它的类型是编译器生成的匿名类型），所以 `auto` 仅能推导它的类型而无法在声明中递归调用自己。



# 面试前必看

### **写复杂的题写注释才好写  复杂题先想想题目可以用什么方法 想好在写 拿笔画一画不要偷懒 一般题目不会直接暴力求** 

## 1.string各种操作  substr  拼接

## 2.map各种操作  

## 3.priority_queue 各种操作 自定义比较

## 4.字符大小写转换的加减法

## 5.algorithm一些常用函数

## 6.*max_element

## 7.pair 

## 8.atio stoi itos itoa

## 9.反转链表 找链表中间



# 一、哈希

两数之和

字母异位词分组



# 二、双指针






**相向双指针**

## 1.两数之和 II - 输入有序数组

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int i = 0; i < n - 2; i++) {
            int x = nums[i];
            if (i && x == nums[i - 1]) continue; // 跳过重复数字
            if (x + nums[i + 1] + nums[i + 2] > 0) break; // 优化一
            if (x + nums[n - 2] + nums[n - 1] < 0) continue; // 优化二
            int j = i + 1, k = n - 1;
            while (j < k) {
                int s = x + nums[j] + nums[k];
                if (s > 0) {
                    k--;
                } else if (s < 0) {
                    j++;
                } else {
                    ans.push_back({x, nums[j], nums[k]});
                    for (j++; j < k && nums[j] == nums[j - 1]; j++); // 跳过重复数字
                    for (k--; k > j && nums[k] == nums[k + 1]; k--); // 跳过重复数字
                }
            }
        }
        return ans;
    }
};
/*
先排序  再双向指针
*/
```





## 2.移动零

## 3.三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int i = 0; i < n - 2; i++) {
            int x = nums[i];
            if (i && x == nums[i - 1]) continue; // 跳过重复数字
            if (x + nums[i + 1] + nums[i + 2] > 0) break; // 优化一
            if (x + nums[n - 2] + nums[n - 1] < 0) continue; // 优化二
            int j = i + 1, k = n - 1;
            while (j < k) {
                int s = x + nums[j] + nums[k];
                if (s > 0) {
                    k--;
                } else if (s < 0) {
                    j++;
                } else {
                    ans.push_back({x, nums[j], nums[k]});
                    for (j++; j < k && nums[j] == nums[j - 1]; j++); // 跳过重复数字
                    for (k--; k > j && nums[k] == nums[k + 1]; k--); // 跳过重复数字
                }
            }
        }
        return ans;
    }
};


```



```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        
        vector<vector<int>> result;
        for(int i=0;i<nums.size()-2;i++)
        {
            int left=i+1;
            int right=nums.size()-1;
            if(i&&nums[i]==nums[i-1]) continue;
            while(left<right)
            {
            if(nums[left]+nums[right]+nums[i]<0) left++;
            else if(nums[right]+nums[left]+nums[i]>0) right--;
            else if(nums[left]+nums[right]+nums[i]==0) 
            {
                result.push_back({nums[i],nums[left],nums[right]});
                  while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                left++;
                right--;
            }
             
            }
        }

        return result;
    }
};
```



## 4.盛最多水的容器



**将两个指针放在两端**

**返回值应该是面积，所以只关心面积（保留max_area），其他量不一定要存储（组成max_area的索引）**



左右指针在两端，长度已经最长了，只需要找到更高的检查面积

 (a-b)*min(x，y)     (a-b)尽量长  限制于min(x-y)   min(x，y)限制于短边  所以要找更长的边

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int max_area = 0;

    while (left < right) {
        // 计算当前左右指针形成的面积
        int area = (right - left) * min(height[left], height[right]);
        max_area = max(max_area, area);

        // 移动较小的一边，试图找到更高的边，增加面积
       if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }

    return max_area;
}

};
```



## 5.接雨水

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        vector<int> left_max(height.size(),0);
        vector<int> right_max(height.size(),0);
        left_max[0]=height[0];
        right_max[height.size()-1] = height[height.size()-1];
        for(int i=1;i<height.size();i++)
        {
            left_max[i]=max(left_max[i-1],height[i]);
        }
        for(int i=height.size()-2;i>=0;i--)
        {
            right_max[i]=max(right_max[i+1],height[i]);
        }

        int sum=0;
        for(int i=0;i<height.size();i++)
        {
            sum+=(min(left_max[i],right_max[i]))-height[i];
        }

        return sum;
    }
};
/*
left_max 和 right_max 没有预分配大小： 在你的代码中，left_max[0] = height[0] 和 right_max[height.size()-1] = height[height.size()-1] 直接访问了未分配大小的向量，导致越界错误。你需要在使用之前分配适当的大小。
*/
```

你可以用双指针法来同时计算左右最大值，省去 `left_max` 和 `right_max` 数组，从而将空间复杂度降低为 O(1)。以下是优化后的代码：

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.empty()) return 0;

        int left = 0, right = height.size() - 1;
        int left_max = 0, right_max = 0;
        int sum = 0;

        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= left_max) {
                    left_max = height[left];
                } else {
                    sum += left_max - height[left];
                }
                left++;
            } else {
                if (height[right] >= right_max) {
                    right_max = height[right];
                } else {
                    sum += right_max - height[right];
                }
                right--;
            }
        }

        return sum;
    }
};
/*
代码的详细步骤：
边界条件： 首先，代码检查输入数组是否为空，如果为空，直接返回 0，因为没有柱子自然也无法积水。

初始化变量：

left 和 right：两个指针分别指向数组的最左边和最右边，表示从数组两端向中间靠拢。
left_max 和 right_max：用于记录从左边和右边遍历过程中遇到的最大柱子高度。用于决定当前列可以积水的高度。
sum：用于累计接到的雨水量。
主循环： 代码通过 while(left < right) 循环，表示在左右指针还没有相遇时，不断处理左右两侧的柱子。

比较 height[left] 和 height[right]，选择较小的高度作为处理的起点。雨水量由较小的一侧决定，所以优先移动较矮的那一侧。
处理较小的一侧： 如果 left 较小，首先检查当前左边柱子的高度是否大于或等于之前记录的左侧最大高度 left_max：

如果大于或等于，说明当前柱子不能积水，因为它成为了新的最高柱子。更新 left_max。
如果小于，说明它位于较高柱子之间，可以积水。积水量为 left_max - height[left]。
处理完后，将 left 向右移动一格，继续处理。
如果 right 较小，右侧的处理逻辑与左侧类似。比较 height[right] 和 right_max：

如果当前右边柱子的高度大于或等于 right_max，则更新 right_max，否则计算积水量并将 right 向左移动。
结束条件： 当 left 和 right 相遇时，循环结束，所有可能积水的位置都已经处理完毕，sum 中累积的值就是接到的雨水总量。

返回结果： 最终返回 sum，即总的雨水量。
*/
```

## 6.压缩字符串

### 将数字转为字符的两种方式(to_string)(‘0’ + ...)

```c++
class Solution {
public:
    //多拿笔画一下不要空想  会容易下标弄错
    //注释多写
    int compress(vector<char>& chars) {
        int write = 0;
        int index = 0;
        int right = 0;
        while(right <= chars.size()){
            if(right < chars.size() && chars[right] == chars[index]){
                right++;
            }
            else{
                int length = right - index;
                chars[write++] = chars[index];
                if(right == chars.size()) right++;
                index = right;
                if(length > 1){
                    int temp = write;
                    while(length > 0){
                        chars[write++] = '0' + length % 10;
                        length = length / 10;
                }
                    reverse(&chars[temp],&chars[write]);
                }
            }
        }
        return write;
    }
};
```

```c++
class Solution {
public:
    int compress(vector<char>& chars) {
        int write = 0;  // 写入位置
        int left = 0;   // 记录当前字符的起始位置
        int n = chars.size();

        while (left < n) {
            char currentChar = chars[left];
            int right = left;
            
            // 计算当前字符的个数
            while (right < n && chars[right] == currentChar) {
                right++;
            }

            // 写入字符
            chars[write++] = currentChar;

            // 如果 count > 1，则写入 count 数字
            int count = right - left;
            if (count > 1) {
                string countStr = to_string(count);
                for (char c : countStr) {
                    chars[write++] = c;
                }
            }

            // 更新 left 位置
            left = right;
        }

        return write;
    }
};
```



# 三、滑动窗口

```python
class Solution:    
    def problemName(self, s: str) -> int:        
        # Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)        
        x, y = ..., ...         
        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口        
        start = 0        for end in range(len(s)):            
        # Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)            
        x = new_x            if condition:                y = new_y             
        '''            
        ------------- 下面是两种情况，读者请根据题意二选1 -------------            
        '''            
        # Step 4 - 情况1            
        # 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度             
        # 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变,             
        # 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量             if 窗口长度达到了限定长度:                		  # 更新 (部分或所有) 维护变量                 
        # 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变             
        # Step 4 - 情况2            
        # 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题            
        # 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法            
        # 在左指针移动之前更新Step 1定义的(部分或所有)维护变量             
        while 不合法:                
        # 更新 (部分或所有) 维护变量                 
        # 不断移动窗口左指针直到窗口再次合法         
        # Step 5: 返回答案        
        return ... 
```

## 1.无重复字符的最长子串



多用set map 效率高

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<char> str;
        int length_max=0;
        int length;
        for(int i=0;i<s.size();i++)
        {
            
            while((find(str.begin(),str.end(),s[i]))!=str.end())
            {
                str.erase(str.begin());
            }
            str.emplace_back(s[i]);
            length=str.size();
            length_max = max(length,length_max);
        }

        return length_max;
    }
};
你在每次循环中使用 find(str.begin(), str.end(), s[i]) 来查找是否存在重复字符。find 在 vector 中的时间复杂度是 O(n)，这使得算法在最坏情况下的时间复杂度变成 O(n²)
```





```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.length(), ans = 0, left = 0;
        unordered_set<char> window; // 维护从下标 left 到下标 right 的字符
        for (int right = 0; right < n; right++) {
            char c = s[right];
            // 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素
            // 所以要在加入 c 之前，先移出窗口内的 c
            while (window.count(c)) { // 窗口内有 c
                window.erase(s[left++]); // 缩小窗口
            }
            window.insert(c); // 加入 c
            ans = max(ans, right - left + 1); // 更新窗口长度最大值
        }
        return ans;
    }
};

unordered_set 基于哈希表实现，count() 函数用于检查某个元素是否存在。由于哈希表的查找、插入和删除操作在平均情况下都是常数时间，即 O(1)，因此 count() 函数的平均时间复杂度也是 O(1)。
不过在 最坏情况下，如果哈希冲突非常多（例如所有元素都映射到同一个哈希桶中），count() 的时间复杂度可能退化为 O(n)
    但通常我们认为哈希表操作的时间复杂度是 O(1)，因为哈希冲突的概率很低。
    使得算法复杂度为o(n)
```

# 四、前缀和

https://leetcode.cn/problems/range-sum-query-immutable/solutions/2693498/qian-zhui-he-ji-qi-kuo-zhan-fu-ti-dan-py-vaar/

## 1.和为K的子数组

**前缀和+哈希表**

**给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。**

**子数组是数组中元素的连续非空序列。**

```
数组先考虑双指针和滑动窗口，想到不是单调，用不了 --》连续数的和--》想到前缀和，前缀和能得到从left到right的和                 --》找pre[right]-pre[left]==k --》pre[left] == pre[right] -k  --》遍历到right时，寻找前面pre[right] - k 的个数
--》想到用哈希表存储前缀和的个数 --》找到有几个等于pre[right] - k 的pre[left] 就把结果加几
```

为什么这题不适合用滑动窗口做？

答：滑动窗口需要满足单调性，当右端点元素进入窗口时，窗口元素和是不能减少的。本题 nums 包含负数，当负数进入窗口时，窗口左端点反而要向左移动，导致算法复杂度不是线性的。



```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> pre_sum;
        pre_sum[0] = 1;  // 初始化前缀和为0的情况
        
        int currentSum = 0;  // 当前的前缀和
        int result = 0;      // 记录和为 k 的子数组的个数
        
        for (int i = 0; i < nums.size(); i++) {
            currentSum += nums[i];  // 累加当前元素到前缀和
            
            // 如果 currentSum - k 存在于哈希表中，说明存在一个以当前元素结尾的子数组，其和为 k
            if (pre_sum.find(currentSum - k) != pre_sum.end()) {
                result += pre_sum[currentSum - k];  // 累加符合条件的子数组个数
            }
            
            // 将当前前缀和存入哈希表，统计出现次数
            pre_sum[currentSum]++;
        }
        
        return result;
    }
};

```

# 五、动态规划

## 1.最大子数组和

### 方法一：前缀和

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> pre_sum(nums.size()+1,0);
        for(int i=1;i<nums.size()+1;i++)
        {
            pre_sum[i]=pre_sum[i-1]+nums[i-1];
        }

        int min_sum=0;
        int max_sum=nums[0];
        for(int i=0;i<nums.size();i++)
        {
            min_sum = min(min_sum,pre_sum[i]);
            max_sum=max(max_sum,pre_sum[i+1]-min_sum);
        }

        return max_sum;
    }
};
/*
两次遍历
*/
```

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int ans = INT_MIN;
        int min_pre_sum = 0;
        int pre_sum = 0;
        for (int x : nums) {
            pre_sum += x; // 当前的前缀和
            ans = max(ans, pre_sum - min_pre_sum); // 减去前缀和的最小值
            min_pre_sum = min(min_pre_sum, pre_sum); // 维护前缀和的最小值
        }
        return ans;
    }
};
/*
一次遍历
*/
```

### 方法二：动态规划

定义 f[i] 表示以 nums[i] 结尾的最大子数组和。

分类讨论：

nums[i] 单独组成一个子数组，那么 f[i]=nums[i]。
nums[i] 和前面的子数组拼起来，也就是在以 nums[i−1] 结尾的最大子数组和之后添加 nums[i]，那么 f[i]=f[i−1]+nums[i]。
两种情况取最大值，得

f[i]={ 
		nums[i], i=0
		max(f[i−1],0)+nums[i], i≥1

​	}


简单地说，如果 nums[i] 左边的子数组元素和是负的，就不用和左边的子数组拼在一起了。

答案为 max(f)。



```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> f(nums.size());
        f[0] = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            f[i] = max(f[i - 1], 0) + nums[i];
        }
        return ranges::max(f);
    }
};


```

## 2.打家劫舍

**看灵神视频，空间还可以优化**

我的写法：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
      vector<int> dp(nums.size(),0);
        dp[0]=nums[0];
        if(nums.size()==1) return dp[0];
        dp[1]=max(dp[0],nums[1]);

      for(int i=2;i<nums.size();i++)
      {
        dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
      }  
      return dp[nums.size()-1];
    }
};
```



## 121.买卖股票最佳时机

### 方法一

赚钱最多--》right_max-left_min 最大--》两个变量  定一移一 --》依次遍历数组  维护一个左侧最小值  计算当前最大利润 --》遍历完数组可得到最大利润

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_price=prices[0];
        int max_profit = 0;

        for(int i=1;i<prices.size();i++)
        {
            max_profit=max(max_profit,prices[i]-min_price);
            min_price=min(prices[i],min_price);
        }

        return max_profit < 0 ? 0 :max_profit;
    }
};
```

### 方法二

思路

> 动态规划方法最核心的就是找到**状态转移方程**，下面详细地为大家讲解一下**dp[i] = fmax(dp[i - 1] + prices[i] - prices[i - 1], 0)**是如何推导出来的。

解题过程

> 首先要明确的是，状态转移方程的核心就是**去避免重复的计算**。 **避免重复的计算，我们就要保存每次计算的值**，因此通过dp数组，我们将**每天的最大利润**保存在了里面。 那么问题就已经缩小至了**求每天的最大利润**。 又因为dp数组的核心之一就是**dp[i]要和dp[i-1]等前面的位置有着紧密的联系**，所以我们要思考**当天的最大利润能否通过前一天的最大利润求出。** 这里我们引入一个简化方法：**A--C==A--B--C** 类似于化学中的盖斯定律，**第二天买入第四天卖出==第二天买入第三天卖出+第三天买入第四天卖出**，数学表达如下: **dp[2]=price[2]-price[1]=5-1=4 dp[3]=price[2]-price[1]+price[3]-price[2]=dp[2]+price[3]-price[2]=5-1+3-5=2** 从而我们找到了**核心状态转移方程**：**dp[i]=dp[i - 1] + prices[i] - prices[i - 1]** 而当我们直接使用时，结果出错，**dp数组出现了负数的情况**，说明我们不能直接使用上面的状态转移方程，接下来我们寻找**使用此方程的前置条件。** 从一个简单的角度思考，**dp[i]在本题中不可能小于0**，那么我们直接加上前置条件，式子变为： **if(dp[i - 1] + prices[i] - prices[i - 1]>0)  dp[i]=dp[i - 1] + prices[i] - prices[i - 1]** 成功通过，简化状态转移方程为：**dp[i] = fmax(dp[i - 1] + prices[i] - prices[i - 1], 0)**

复杂度

- 时间复杂度: O(n
- 空间复杂度: O(n)

```c
int maxProfit(int* prices, int pricesSize) {
    if (pricesSize < 2)
        return 0;
    int i = 0, max = 0, dp[pricesSize];
    dp[i] = 0;
    for (i = 1; i < pricesSize; i++) {  //构建dp数组
        dp[i] = fmax(dp[i - 1] + prices[i] - prices[i - 1], 0);  //核心状态转移方程
        max = dp[i] > max ? dp[i] : max;  //记录dp数组中出现的最大数
    }
    return max;
}

```

# 六、简单的数组

## 1.最大子数组和

## 2.轮转数组(用三种方法)

### 方法一  创建额外数组空间

### 方法二  不创建额外数组空间  利用取余(%)和一个中间变量完成对原数组轮转

### 方法三  利用reverse反转vector

# 七、螺旋问题

## 1.螺旋矩阵

### 方法一

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
         if(matrix.size() == 0 || matrix[0].size() == 0)
    return {};

    vector<int>ans;
    int lineBegin = 0, lineEnd = matrix[0].size() - 1; //记录行的开头与结尾
    int listBegin = 0, listEnd = matrix.size() - 1; //记录列的开头与结尾

    while(true)
    {
        //从左往右
        for(int i = lineBegin; i <= lineEnd; i++)
        ans.push_back(matrix[listBegin][i]);
        if(++listBegin > listEnd) break;

        //从上往下
        for(int i = listBegin; i <= listEnd; i++)
        ans.push_back(matrix[i][lineEnd]);
        if(--lineEnd < lineBegin) break;

        //从右往左
        for(int i = lineEnd; i >= lineBegin; i--)
        ans.push_back(matrix[listEnd][i]);
        if(--listEnd < listBegin) break;

        //从下往上
        for(int i = listEnd; i >= listBegin; i--)
        ans.push_back(matrix[i][lineBegin]);
        if(++lineBegin > lineEnd) break;
    }
    return ans;
    }
};
```

### 方法二

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return {};
        }

        int rows = matrix.size(), columns = matrix[0].size();
        vector<int> order;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left <= right && top <= bottom) {
            for (int column = left; column <= right; column++) {
                order.push_back(matrix[top][column]);
            }
            for (int row = top + 1; row <= bottom; row++) {
                order.push_back(matrix[row][right]);
            }
            if (left < right && top < bottom) {
                for (int column = right - 1; column > left; column--) {
                    order.push_back(matrix[bottom][column]);
                }
                for (int row = bottom; row > top; row--) {
                    order.push_back(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return order;
    }
};


```

我的代码：

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        int lbegin=0;
        int lend=matrix[0].size()-1;

        int rbegin=0;
        int rend=matrix.size()-1;

        while(1)
        {
            for(int i=lbegin;i<lend;i++){result.emplace_back(matrix[rbegin][i]);}
            if(rbegin>rend||lbegin>lend) break;
            if(rbegin==rend) {result.emplace_back(matrix[rbegin][lend]);break;}
            
            for(int j=rbegin;j<rend;j++){result.emplace_back(matrix[j][lend]);}
            if(rbegin>rend||lbegin>lend) break;
            if(lbegin==lend){result.emplace_back(matrix[rend][lbegin]);break;}
           

            for(int i=lend;i>lbegin;i--){result.emplace_back(matrix[rend][i]);}
           
            for(int j=rend;j>rbegin;j--){result.emplace_back(matrix[j][lbegin]);}

            lbegin++;
            lend--;
            rbegin++;
            rend--;
            if(rbegin>rend||lbegin>lend) break;
        }

        return result;
    }
};
```



## 2.螺旋矩阵II

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int x=(n+1)/2;
        vector<vector<int>> res(n,vector<int>(n));
        int y=0;
        int t=1;
       while(x--)
       {
            for(int i=y;i<n-y-1;i++)
            {
                res[y][i]=t++;
            }
            for(int i=y;i<n-y-1;i++)
            {
                res[i][n-1-y]=t++;
            }
            for(int i=n-1-y;i>y;i--)
            {
                res[n-1-y][i]=t++;
            }
            for(int i=n-1-y;i>y;i--)
            {
                res[i][y]=t++;
            }
            y++;
       }
        if(n%2!=0) res[(n-1)/2][(n-1)/2]=t;

        return res;
    }
};
```

## 3.旋转图像

我的代码：

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int t=0;
        for(int i=0;i<matrix.size()-1;i++)
        {
            for(int j=0;i<matrix[0].size();j++)
            {
                swap(matrix[i][j+t+1],matrix[j+t+1][i]);
                if(j+t+1==matrix.size()-1) break;
            }
            t++;
        }

        for(int i=0;i<matrix.size();i++)
        {
            reverse(matrix[i].begin(),matrix[i].end());
        }
        
    }
};
```

还可以两次翻转：

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                swap(matrix[i][j], matrix[n - i - 1][j]);
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};
```

# 八、链表

**在什么情况下，要用到哨兵节点（dummy node）？**
**在什么情况下，循环条件要写 while (node != null)？什么情况下要写 while (node.next != null)？**

## 1.相交链表

### 方法一 利用哈希表存储节点（空间复杂度较高）

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode *> visited;
        ListNode *temp = headA;
        while (temp != nullptr) {
            visited.insert(temp);
            temp = temp->next;
        }
        temp = headB;
        while (temp != nullptr) {
            if (visited.count(temp)) {
                return temp;
            }
            temp = temp->next;
        }
        return nullptr;
    }
};


```

### 方法二

![](C:\Users\86138\Pictures\QQ20241027-140528.png)

```c++
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode* p = headA;
        ListNode* q = headB;
        while (p != q) {
            p = (p ? p->next : headB);
            q = (q ? q->next : headA);
        }
        return p;
    }
};
```

**`p != q`**：判断 `p` 和 `q` 这两个指针是否指向同一个地址。`p` 和 `q` 是 `ListNode` 类型的指针，所以 `p != q` 表示 `p` 和 `q` 是否指向同一个节点，而不是判断它们指向的节点内容是否相同。

**`\*p != \*q`**：判断 `p` 和 `q` 指向的节点的内容是否相同。`*p` 和 `*q` 是指针的解引用操作，即取得 `p` 和 `q` 所指向的节点内容，因此 `*p != *q` 会比较两个节点中的数据成员是否相同。通常在这里我们并不需要 `*p != *q`，因为这个函数只需要找到两个链表的交点，即地址相同的节点，而不关心节点内容是否相同。

## 2.反转链表

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur = head, *pre = nullptr;
        while(cur != nullptr) {
            ListNode* tmp = cur->next; // 暂存后继节点 cur.next
            cur->next = pre;           // 修改 next 引用指向
            pre = cur;                 // pre 暂存 cur
            cur = tmp;                 // cur 访问下一节点
        }
        return pre;
    }
};
```

## 3.链表的中间节点

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *fast = head, *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```



## 4.回文链表

```c++
class Solution {
    // 876. 链表的中间结点
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    // 206. 反转链表
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr, *cur = head;
        while (cur) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

public:
    bool isPalindrome(ListNode* head) {
        ListNode* mid = middleNode(head);
        ListNode* head2 = reverseList(mid);
        while (head2) {
            if (head->val != head2->val) { // 不是回文链表
                return false;
            }
            head = head->next;
            head2 = head2->next;
        }
        return true;
    }
};
```



我的代码：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* p = head;
        if (p->next == nullptr)return true;
        
        //中间节点
        int i = 0;
        while (p != nullptr) {
            p = p->next;
            i++;
        }
        if (i % 2 != 0) i = i / 2 + 1;
        else i = i / 2;
        ListNode* t = head;
        while (i--) t = t->next;

        //反转链表
        ListNode* x = t;
        ListNode* y = nullptr;
        while (t != nullptr) {
            t = t->next;
            x->next = y;
            y = x;
            x = t;
        }

        ListNode* q = head;
        while (y != nullptr) {
            if (q->val != y->val)
                return false;
            q = q->next;
            y = y->next;
        }

        return true;
    }
};
```

## 5.环形链表

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        if(head==nullptr) return false;
        while(fast->next!=nullptr&&fast->next->next!=nullptr)
        {
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow) return true;
        }

        return false;
    }
};
```

## 6.环形链表II

### 方法一 哈希表

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode*> ref;
        ListNode* p = head;
        while(p!=nullptr)
        {
            if(ref.find(p)!=ref.end())
            {
                return p;
            }
            ref.emplace(p);
            p=p->next;
        }

        return nullptr;
    }
};
```

### 方法二  快慢指针

**相遇之处**  和  **链表头**  距离**环入口**距离相等

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (true) {
            if (fast == nullptr || fast->next == nullptr) return nullptr;
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) break;
        }
        fast = head;
        while (slow != fast) {
            slow = slow->next;
            fast = fast->next;
        }
        return fast;
    }
};
```

## 7.合并两个有序链表  合并K个升序链表

**哨兵节点的运用** **链表怎么建立的也要会**

### 两个

```c++

  //Definition for singly-linked list.
  struct ListNode {
      int val;
      ListNode *next;
      ListNode() : val(0), next(nullptr) {}
      ListNode(int x) : val(x), next(nullptr) {}
      ListNode(int x, ListNode *next) : val(x), next(next) {}
  };
 
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy;
        ListNode* cur = &dummy;
        while(list1 != nullptr && list2 != nullptr){
            if(list1->val < list2->val){
                cur->next = list1;
                list1 = list1->next;
            }
            else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        if(list1 != nullptr) cur->next = list1;
        if(list2 != nullptr) cur->next = list2;
        return dummy.next;
    }
};
```

### K个

#### 顺序合并 O k^2n

```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode dummy;
        ListNode* cur = &dummy;
        for(int i = 0;i < lists.size();i++){
            ListNode* node = dummy.next;
            cur = &dummy;
            while(node != nullptr && lists[i] != nullptr){
                if(node->val < lists[i]->val){
                    cur->next = node;
                    node = node->next;
                    cur = cur->next;
                }
                else {
                    cur->next = lists[i];
                    lists[i] = lists[i]->next;
                    cur = cur->next;
                }
            }
            if(node) cur->next = node;
            if(lists[i]) cur->next = lists[i];
        }
        return dummy.next;
    }
};
```

#### 最小堆 O nlogk

```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode* > &lists) {
        auto cmp = [](const ListNode* a, const ListNode* b) {
            return a->val > b->val; // 最小堆
        };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq;
        for (auto head: lists) {
            if (head) {
                pq.push(head);
            }
        }

        ListNode dummy{}; // 哨兵节点，作为合并后链表头节点的前一个节点
        auto cur = &dummy;
        while (!pq.empty()) { // 循环直到堆为空
            auto node = pq.top(); // 剩余节点中的最小节点
            pq.pop();
            if (node->next) { // 下一个节点不为空
                pq.push(node->next); // 下一个节点有可能是最小节点，入堆
            }
            cur->next = node; // 合并到新链表中
            cur = cur->next; // 准备合并下一个节点
        }
        return dummy.next; // 哨兵节点的下一个节点就是新链表的头节点
    }
};
```

#### 分治 O nlogk

```c++
class Solution {
    // 21. 合并两个有序链表
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy{}; // 用哨兵节点简化代码逻辑
        auto cur = &dummy; // cur 指向新链表的末尾
        while (list1 && list2) {
            if (list1->val < list2->val) {
                cur->next = list1; // 把 list1 加到新链表中
                list1 = list1->next;
            } else { // 注：相等的情况加哪个节点都是可以的
                cur->next = list2; // 把 list2 加到新链表中
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2; // 拼接剩余链表
        return dummy.next;
    }

    // 合并从 lists[i] 到 lists[j-1] 的链表
    ListNode* mergeKLists(vector<ListNode*>& lists, int i, int j) {
        int m = j - i;
        if (m == 0) {
            return nullptr; // 注意输入的 lists 可能是空的
        }
        if (m == 1) {
            return lists[i]; // 无需合并，直接返回
        }
        auto left = mergeKLists(lists, i, i + m / 2); // 合并左半部分
        auto right = mergeKLists(lists, i + m / 2, j); // 合并右半部分
        return mergeTwoLists(left, right); // 最后把左半和右半合并
    }

public:
    ListNode* mergeKLists(vector<ListNode* > &lists) {
        return mergeKLists(lists, 0, lists.size());
    }
};
```



## 8.两数相加（重要） （对于链表指针的理解）（p只是指向Node，没有真正连接到Node上）（哨兵节点）

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy; // 哨兵节点
        ListNode* cur = &dummy;
        int carry = 0; // 进位
        while (l1 || l2 || carry) { // 有一个不是空节点，或者还有进位，就继续迭代
            int sum = carry + (l1 ? l1->val : 0) + (l2 ? l2->val : 0); // 节点值和进位加在一起
            cur = cur->next = new ListNode(sum % 10); // 每个节点保存一个数位
            carry = sum / 10; // 新的进位
            if (l1) l1 = l1->next; // 下一个节点
            if (l2) l2 = l2->next; // 下一个节点
        }
        return dummy.next; // 哨兵节点的下一个节点就是头节点
    }
};
```

我的代码：

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy;
        ListNode* cur = &dummy;
        int carry = 0;
        int sum = 0;
        while(l1 != nullptr && l2 != nullptr){    
            sum = l1->val + l2->val + carry;
            carry = sum / 10;
            l1->val = sum % 10;
            cur->next = l1;
            cur = l1;
            l1 = l1->next;
            l2 = l2->next;
        }
        if(l1 == nullptr){
            while(l2 != nullptr){
                sum = carry + l2->val;
                carry = sum / 10;
                l2->val = sum % 10;
                cur->next = l2;
                cur = l2;
                l2 = l2->next;
            }
        }
        if(l2 == nullptr){
            while(l1 != nullptr){
                sum = carry + l1->val;
                carry = sum / 10;
                l1->val = sum % 10;
                cur->next = l1;
                cur = l1;
                l1 = l1->next;
            }
        }
        if(carry != 0){
            ListNode* tail = new ListNode(carry);
            cur->next = tail;
        }
        return dummy.next;
    }
};
```

## 9.删除链表的倒数第 N 个结点

### 哨兵节点！！！

我的写法：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int p = 0;
        ListNode* q =head;
        
        while(q)
        {
            p++;
            q=q->next;
        }
        
        p=p-n;
        ListNode dummy = ListNode(0,head);
        ListNode* pre = &dummy; 
        
        for(;p>0;p--)
        {
           pre=pre->next;
        }

        pre->next=pre->next->next;

        return dummy.next;
    }
};
```

### 双指针（有争议）

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 由于可能会删除链表头部，用哨兵节点简化代码
        ListNode dummy{0, head};
        ListNode* left = &dummy;
        ListNode* right = &dummy;
        while (n--) {
            right = right->next; // 右指针先向右走 n 步
        }
        while (right->next) {
            left = left->next;
            right = right->next; // 左右指针一起走
        }
        // 左指针的下一个节点就是倒数第 n 个节点
        ListNode* nxt = left->next;
        left->next = left->next->next;
        delete nxt;
        return dummy.next;
    }
};
/*
前后指针（不是快慢指针）是个好思想，但是这道题的“one-pass”要求根本不合理。原因之一，前后指针到底算不算“one-pass”属于文字游戏，从代码形式上看确实少了一个 for，但从操作次数上看，与单指针走两遍并无区别
*/
```

## 10.两两交换链表中的节点

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode dummy{0};
        ListNode* cur = &dummy;
        cur->next = head;
        while(cur->next && cur->next->next){
            ListNode* left = cur->next;
            ListNode* right = cur->next->next;
            ListNode* temp = right->next;

            cur->next = right;
            right->next = left;
            left->next = temp;
            
            cur = left;
            left = temp;
            if(left) right = left->next;
        }
        return dummy.next;
    }
};
```

## 11.K个一组翻转链表(上一题升级版)(多写写 主要锻炼下标与细节处理)

### 没什么难的思路 主要过程繁琐易出错

```c++
class Solution {
public:
    pair<ListNode*,ListNode*> revs(ListNode* node){
        ListNode* cur = node;
        ListNode* pre = nullptr;
        ListNode* tail = node; 
        while(cur){
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return {pre,node};
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* node = new ListNode();
        node->next = head;
        ListNode* res = head;
        ListNode* temp;
        int flag = 0;
        while(node != nullptr){
            ListNode* temp2;
            for(int i = 0;i < k;i++){
                node = node->next;
                if(node == nullptr) return res;
            }
            temp2 = node->next;
            node->next = nullptr;
            auto [ans,tail] = revs(head);
            if(flag == 0){
                res = ans;
                flag++;
            }
            else {
                temp->next = ans;
            }
            temp = tail;
            tail->next = temp2;
            head = temp2;
            node = tail;
        }
        return res;
    }
};
```

## 12.随机链表的复制

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }

        // 复制每个节点，把新节点直接插到原节点的后面
        for (Node* cur = head; cur; cur = cur->next->next) {
            cur->next = new Node(cur->val, cur->next, nullptr);
        }

        // 遍历交错链表中的原链表节点
        for (Node* cur = head; cur; cur = cur->next->next) {
            if (cur->random) {
                // 要复制的 random 是 cur->random 的下一个节点
                cur->next->random = cur->random->next;
            }
        }

        // 把交错链表分离成两个链表
        Node* new_head = head->next;
        Node* cur = head;
        for (; cur->next->next; cur = cur->next) {
            Node* copy = cur->next;
            cur->next = copy->next; // 恢复原节点的 next
            copy->next = copy->next->next; // 设置新节点的 next
        }
        cur->next = nullptr; // 恢复原节点的 next //这一步很重要
        return new_head;
    }
};
```

## 13.排序链表(链表的归并排序)

```c++
class Solution {
    // 876. 链表的中间结点（快慢指针）
    ListNode* middleNode(ListNode* head) {
        ListNode* pre = head;
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            pre = slow; // 记录 slow 的前一个节点
            slow = slow->next;
            fast = fast->next->next;
        }
        pre->next = nullptr; // 断开 slow 的前一个节点和 slow 的连接
        return slow;
    }

    // 21. 合并两个有序链表（双指针）
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy; // 用哨兵节点简化代码逻辑
        ListNode* cur = &dummy; // cur 指向新链表的末尾
        while (list1 && list2) {
            if (list1->val < list2->val) {
                cur->next = list1; // 把 list1 加到新链表中
                list1 = list1->next;
            } else { // 注：相等的情况加哪个节点都是可以的
                cur->next = list2; // 把 list2 加到新链表中
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2; // 拼接剩余链表
        return dummy.next;
    }

public:
    ListNode* sortList(ListNode* head) {
        // 如果链表为空或者只有一个节点，无需排序
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        // 找到中间节点，并断开 head2 与其前一个节点的连接
        // 比如 head=[4,2,1,3]，那么 middleNode 调用结束后 head=[4,2] head2=[1,3]
        ListNode* head2 = middleNode(head);
        // 分治
        head = sortList(head);
        head2 = sortList(head2);
        // 合并
        return mergeTwoLists(head, head2);
    }
};
```



# 九、LRU缓存(背下来)

## LRU和LFU区别？

**特性	LRU (Least Recently Used)	LFU (Least Frequently Used)**

**依据	最久未使用的元素	最少使用的元素（访问频率）**

**淘汰条件	最近未使用的元素被淘汰	访问频率最低的元素被淘汰**

## 1.LRU缓存

```c++
class Node{
public:
    int key;
    int value;
    Node* prev;
    Node* next;
    Node(int k = 0,int v = 0) : key(k), value(v){}
};

class LRUCache {
public:
    int capacity;
    Node* dummy;
    unordered_map<int,Node*> key_to_node;

    void remove(Node* node){
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void push_front(Node* node){
        node->next = dummy->next;
        node->prev = dummy;
        dummy->next = node;
        node->next->prev = node;
    }

    Node* get_node(int key){
        auto it = key_to_node.find(key);
        if(it == key_to_node.end()) return nullptr;
        Node* node = key_to_node[key];
        remove(node);
        push_front(node);
        return node;
    }

    LRUCache(int capacity) : capacity(capacity),dummy(new Node()) {
        dummy->prev = dummy;
        dummy->next = dummy;
    }
    
    int get(int key) {
        Node* node = get_node(key);
        return node ? node->value : -1;
    }
    
    void put(int key, int value) {
        Node* node = get_node(key);
        if(node){
            node->value = value;
            return;
        }
        node = new Node(key,value);
        key_to_node[key] = node;
        push_front(node);
        if(key_to_node.size() > capacity){
            Node* back_node = dummy->prev;
            key_to_node.erase(back_node->key);
            remove(back_node);
            delete back_node;
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



### 在LRU的基础上要求增加过期时间，过期的key要删除掉，刷这题的同学不妨多一些思考

**time_t time(NULL) 时间戳 单位:秒  int expiration_time  单位也代表秒**

```c++
#include <unordered_map>
#include <ctime>

class Node{
public:
    int key;
    int value;
    Node* prev;
    Node* next;
    time_t timestamp;  // 新增：记录节点的插入时间

    Node(int k = 0, int v = 0) : key(k), value(v), timestamp(time(NULL)) {}
};

class LRUCache {
public:
    int capacity;
    Node* dummy;
    unordered_map<int, Node*> key_to_node;
    int expiration_time; // 新增：过期时间

    LRUCache(int capacity, int expiration_time) : capacity(capacity), expiration_time(expiration_time), dummy(new Node()), expiration_time(expiration_time) {
        dummy->prev = dummy;
        dummy->next = dummy;
    }

    void remove(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void push_front(Node* node) {
        node->next = dummy->next;
        node->prev = dummy;
        dummy->next = node;
        node->next->prev = node;
    }

    Node* get_node(int key) {
        auto it = key_to_node.find(key);
        if (it == key_to_node.end()) return nullptr;
        Node* node = key_to_node[key];
        
        // 检查是否过期
        if (time(NULL) - node->timestamp > expiration_time) {
            remove(node);
            key_to_node.erase(key);
            delete node;
            return nullptr;  // 返回空，表示节点已过期
        }

        remove(node);
        push_front(node);
        return node;
    }

    int get(int key) {
        Node* node = get_node(key);
        return node ? node->value : -1;
    }

    void put(int key, int value) {
        Node* node = get_node(key);
        if (node) {
            node->value = value;
            node->timestamp = time(NULL);  // 更新时间戳
            return;
        }

        // 如果没有找到节点，创建新节点
        node = new Node(key, value);
        key_to_node[key] = node;
        push_front(node);

        if (key_to_node.size() > capacity) {
            Node* back_node = dummy->prev;
            key_to_node.erase(back_node->key);
            remove(back_node);
            delete back_node;
        }
    }
    
    void clean_expired() {
        // 清理过期节点的方法
        Node* curr = dummy->next;
        while (curr != dummy) {
            if (time(NULL) - curr->timestamp > expiration_time) {
                Node* next_node = curr->next;
                remove(curr);
                key_to_node.erase(curr->key);
                delete curr;
                curr = next_node;
            } else {
                curr = curr->next;
            }
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity, expiration_time);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */

```

## 2.LFU缓存

```c++
class Node {
public:
    int key;
    int value;
    int freq = 1; // 新书只读了一次
    Node* prev;
    Node* next;

    Node(int k = 0, int v = 0) : key(k), value(v) {}
};

class LFUCache {
private:
    int min_freq;
    int capacity;
    unordered_map<int, Node*> key_to_node;
    unordered_map<int, Node*> freq_to_dummy;

    Node* get_node(int key) {
        auto it = key_to_node.find(key);
        if (it == key_to_node.end()) { // 没有这本书
            return nullptr;
        }
        Node* node = it->second; // 有这本书
        remove(node); // 把这本书抽出来
        Node* dummy = freq_to_dummy[node->freq];
        if (dummy->prev == dummy) { // 抽出来后，这摞书是空的
            freq_to_dummy.erase(node->freq); // 移除空链表
            delete dummy; // 释放内存
            if (min_freq == node->freq) { // 这摞书是最左边的
                min_freq++;
            }
        }
        push_front(++node->freq, node); // 放在右边这摞书的最上面
        return node;
    }

    // 创建一个新的双向链表
    Node* new_list() {
        Node* dummy = new Node(); // 哨兵节点
        dummy->prev = dummy;
        dummy->next = dummy;
        return dummy;
    }

    // 在链表头添加一个节点（把一本书放在最上面）
    void push_front(int freq, Node* x) {
        auto it = freq_to_dummy.find(freq);
        if (it == freq_to_dummy.end()) { // 这摞书是空的
            it = freq_to_dummy.emplace(freq, new_list()).first;
        }
        Node* dummy = it->second;
        x->prev = dummy;
        x->next = dummy->next;
        x->prev->next = x;
        x->next->prev = x;
    }

    // 删除一个节点（抽出一本书）
    void remove(Node* x) {
        x->prev->next = x->next;
        x->next->prev = x->prev;
    }

public:
    LFUCache(int capacity) : capacity(capacity) {}

    int get(int key) {
        Node* node = get_node(key);
        return node ? node->value : -1;
    }

    void put(int key, int value) {
        Node* node = get_node(key);
        if (node) { // 有这本书
            node->value = value; // 更新 value
            return;
        }
        if (key_to_node.size() == capacity) { // 书太多了
            Node* dummy = freq_to_dummy[min_freq];
            Node* back_node = dummy->prev; // 最左边那摞书的最下面的书
            key_to_node.erase(back_node->key);
            remove(back_node); // 移除
            delete back_node; // 释放内存
            if (dummy->prev == dummy) { // 这摞书是空的
                freq_to_dummy.erase(min_freq); // 移除空链表
                delete dummy; // 释放内存
            }
        }
        key_to_node[key] = node = new Node(key, value); // 新书
        push_front(1, node); // 放在「看过 1 次」的最上面
        min_freq = 1;
    }
};
```



# 十、二叉树

## 1.二叉树的中序遍历      (144前序，145后序，102层序)

### 方法一  递归

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;

    void tree_load(TreeNode* p)
    {
        if(p==nullptr) return;
        tree_load(p->left);
        res.emplace_back(p->val);
        tree_load(p->right);
        return;
    }

    vector<int> inorderTraversal(TreeNode* root) {
        tree_load(root);
        return res;

    }
};
/*
时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。

空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。
*/
```

### 方法二 迭代

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> load;						//使用栈
        vector<int> res;
        while (!load.empty() || root != nullptr) {
            if (root == nullptr) {
                root = load.top();
                load.pop();
                res.emplace_back(root->val);
                root = root->right;
                continue;
            }
            load.push(root);
            root = root->left;
        }
        return res;
    }
};
```



### 方法三 Morris（了解）

![](C:\Users\86138\Pictures\QQ20241030-160800.png)

![](C:\Users\86138\Pictures\QQ20241030-160823.png)

## 2.二叉树的层序遍历 （广度优先模版）（使用队列）

方法一：两个数组

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode *root) {
        if (root == nullptr) return {};
        vector<vector<int>> ans;
        vector<TreeNode*> cur = {root};
        while (cur.size()) {
            vector<TreeNode*> nxt;
            vector<int> vals;
            for (auto node : cur) {
                vals.push_back(node->val);
                if (node->left)  nxt.push_back(node->left);
                if (node->right) nxt.push_back(node->right);
            }
            cur = move(nxt);
            ans.emplace_back(vals);
        }
        return ans;
    }
};
```

复杂度分析
时间复杂度：O(n)，其中 n 为二叉树的节点个数。
空间复杂度：O(n)。满二叉树（每一层都填满）最后一层有大约 n/2 个节点，因此数组中最多有 O(n) 个元素，所以空间复杂度是 O(n) 的。
方法二：一个队列

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode *root) {
        if (root == nullptr) return {};
        vector<vector<int>> ans;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            vector<int> vals;
            for (int n = q.size(); n--;) {
                auto node = q.front();
                q.pop();
                vals.push_back(node->val);
                if (node->left)  q.push(node->left);
                if (node->right) q.push(node->right);
            }
            ans.emplace_back(vals);
        }
        return ans;
    }
};
```

复杂度分析
时间复杂度：O(n)，其中 n 为二叉树的节点个数。
空间复杂度：O(n)。满二叉树（每一层都填满）最后一层有大约 n/2 个节点，因此队列中最多有 O(n) 个元素，所以空间复杂度是 O(n) 的。



## 3.二叉树的最大深度 

### 方法一 递归  深度优先

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```

### 方法二  广度优先 层序遍历

## 4.二叉树的最小深度

### 方法一 递归

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        if(!root->left) return minDepth(root->right)+1;
        if(!root->right) return minDepth(root->left)+1;
        return min(minDepth(root->left),minDepth(root->right))+1;
    }
};
```

### 方法二  广度优先 层序遍历

## 5.二叉树的右视图

### 方法一 层次遍历   广度优先搜索

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> cur;
        TreeNode* p =nullptr;
        if(root == nullptr) return res;
        cur.push(root);
        while(cur.size()!=0)
        {
            int n=cur.size();//正序写不容易出错
            for(int i=0;i<n;i++) //遍历到最右节点加入
            {
                p = cur.front();
                if(i==n-1) res.emplace_back(p->val);
                cur.pop();
                if(p->left!=nullptr) cur.push(p->left);
                if(p->right!=nullptr) cur.push(p->right);
                
            }

        }

        return res;
    }
};
```

### 方法二 深度优先搜索

```c++
class Solution {
    vector<int> ans;

    void dfs(TreeNode* node, int depth) {
        if (node == nullptr) {
            return;
        }
        if (depth == ans.size()) { // 这个深度首次遇到
            ans.push_back(node->val);
        }
        dfs(node->right, depth + 1); // 先递归右子树，保证首次遇到的一定是最右边的节点
        dfs(node->left, depth + 1);
    }

public:
    vector<int> rightSideView(TreeNode* root) {
        dfs(root, 0);
        return ans;
    }
};
```

## **6.验证二叉搜索树 

### 方法一 递归

我的代码

你的 `isValidBST` 实现思路存在一些问题。当前代码仅仅检查了直接子节点与当前节点的关系，没有确保整棵树中的所有节点满足二叉搜索树 (BST) 的要求。例如，在一个有效的 BST 中，左子树的所有节点都应该小于根节点，而右子树的所有节点都应该大于根节点。仅检查左、右节点的值不足以验证这点。

解决方案是引入一个范围 (区间)，在递归时限制每个节点的值，使它落在该区间内。具体来说，每个节点应满足：

- 左子树的所有节点小于当前节点的值。

- 右子树的所有节点大于当前节点的值。

  经过修改：

  ```c++
  class Solution {
  public:
      bool isValidBST(TreeNode* root, long long min_val = LLONG_MIN, long long max_val = LLONG_MAX) {
          if (root == nullptr) return true;
          
          // 检查当前节点是否在合法的范围内
          if (root->val <= min_val || root->val >= max_val) return false;
          //验证不合法只需要一个条件不满足
          //验证合法需要所有条件满足
          //所有把问题转换为验证不合法更简洁
  
          // 对左、右子树递归检查，同时调整合法范围
          return isValidBST(root->left, min_val, root->val) && 
                 isValidBST(root->right, root->val, max_val);
      }
  };
  ```

### 方法二 （前序中序后序）遍历

[前序中序后序，三种方法]: https://leetcode.cn/problems/validate-binary-search-tree/solutions/2020306/qian-xu-zhong-xu-hou-xu-san-chong-fang-f-yxvh/



## 7.二叉树的最近公共祖先

我的代码：

```c++
class Solution {
public:
    bool findtree(TreeNode* cur, TreeNode* find) {
        if (cur == find)
            return true;
        if (cur == nullptr)
            return false;
        return findtree(cur->left,find) || findtree(cur->right,find);
    }
    
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
         if (findtree(root->left, p) && findtree(root->left, q))
            return lowestCommonAncestor(root->left, p, q);
        else if (findtree(root->right, p) && findtree(root->right, q))
            return lowestCommonAncestor(root->right, p, q);
        return root;
    }
};
```

非常好的代码，认真理解：![236.png](https://pic.leetcode.cn/1681546069-BZfraI-236.png)

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) {
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left && right) { // 左右都找到
            return root; // 当前节点是最近公共祖先
        }
        return left ? left : right;
    }
};
```

## 8.二叉搜索树的最近公共祖先

### 方法一  递归

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root->val>p->val && root->val>q->val)
            return lowestCommonAncestor(root->left,p,q);
        else if(root->val<p->val && root->val<q->val)
            return lowestCommonAncestor(root->right,p,q);
        return root;
    }
};
```

### 方法二 迭代

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while (root != nullptr) {
            if (root->val < p->val && root->val < q->val) // p,q 都在 root 的右子树中
                root = root->right; // 遍历至右子节点
            else if (root->val > p->val && root->val > q->val) // p,q 都在 root 的左子树中
                root = root->left; // 遍历至左子节点
            else break;
        }
        return root;
    }
};
```

## 9.二叉树的锯齿形层序遍历

### 方法一 两个数组

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == nullptr) return res;
        vector<TreeNode*> next;
        vector<TreeNode*> cur;
        cur.emplace_back(root);
        int index = 1;
        
        while(!cur.empty()) {
            
            vector<int> mid;
            int n = cur.size();
            
            // 遍历当前层的节点
            for(int i = 0; i < n; i++) {
                TreeNode* node = cur[i];
                mid.push_back(node->val);
                
                // 将左右子节点加入 next 队列
                if(node->left != nullptr) next.push_back(node->left);
                if(node->right != nullptr) next.push_back(node->right);
            }
            
            // 如果是偶数层，则需要反转
            if(index % 2 == 0) {
                reverse(mid.begin(), mid.end());
            }
            
            res.push_back(mid); // 添加当前层的结果
            index++;
            cur =move(next); // 将 next 作为新的当前层
        }
        
        return res;
    }
};
/*
mid 和 next 都不需要手动调用 clear()，原因如下：

mid 的作用域：
mid 是在每次 while 循环的开头被重新定义的，因此在每次循环开始时都会被重新初始化为空。也就是说，mid 的数据在每一层结束时并不会被保留到下一层。这样可以避免手动清空 mid。

next 的赋值方式：
在 cur = move(next); 这一行中，我们使用了 move 将 next 的内容转移给 cur。move 操作会将 next 的资源转移给 cur，并使 next 变为空。这种方法不仅避免了手动清空 next，还提高了效率，减少了内存的重复分配。
*/
```

## 方法二 一个队列

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode *root) {
        if (root == nullptr) return {};
        vector<vector<int>> ans;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            vector<int> vals;
            for (int n = q.size(); n--;) {
                auto node = q.front();
                q.pop();
                vals.push_back(node->val);
                if (node->left)  q.push(node->left);
                if (node->right) q.push(node->right);
            }
            if (ans.size() % 2) ranges::reverse(vals);
            ans.emplace_back(vals);
        }
        return ans;
    }
};
```

## 10.找树左下角的值

BFS 这棵二叉树，先把**右**儿子入队，再把**左**儿子入队，这样最后一个出队的节点就是左下角的节点了。

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode *root) {
        TreeNode *node;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            node = q.front(); q.pop();
            if (node->right) q.push(node->right);
            if (node->left)  q.push(node->left);
        }
        return node->val;
    }
};
```

我的代码：

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
       vector<TreeNode*> cur,next;
        cur.emplace_back(root);
       while(cur.size() != 0)
       {
            int n = cur.size();
            for(int i = 0;i < n;i++)
            {
                if(cur[i]->left != nullptr) next.emplace_back(cur[i]->left);
                if(cur[i]->right != nullptr) next.emplace_back(cur[i]->right);
            }
            if(next.size() == 0) return cur[0]->val;
            cur = move(next);
       }
        return root->val;
    }
};
```

## **11.构造二叉树

### 	a.前序中序

![Picture1.png](https://pic.leetcode-cn.com/1629825510-roByLr-Picture1.png)

```c++
class Solution { 
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        
        // 创建哈希表 index，将中序遍历数组的值和索引对应起来，便于查找
        unordered_map<int, int> index;
        for (int i = 0; i < n; i++) {
            index[inorder[i]] = i; // 记录值在 inorder 中的索引位置
        }

        // 定义递归函数 dfs，用于构建树，lambda 表达式用于局部函数定义
        function<TreeNode*(int, int, int, int)> dfs = [&](int pre_l, int pre_r, int in_l, int in_r) -> TreeNode* {
            // 递归基准条件：当前序遍历范围为空时，返回 nullptr
            if (pre_l == pre_r) {
                return nullptr;
            }

            // 计算左子树的节点数
            int left_size = index[preorder[pre_l]] - in_l;

            // 递归构建左子树：
            // 前序范围为 [pre_l + 1, pre_l + 1 + left_size)
            // 中序范围为 [in_l, in_l + left_size)
            TreeNode* left = dfs(pre_l + 1, pre_l + 1 + left_size, in_l, in_l + left_size);

            // 递归构建右子树：
            // 前序范围为 [pre_l + 1 + left_size, pre_r)
            // 中序范围为 [in_l + 1 + left_size, in_r)
            TreeNode* right = dfs(pre_l + 1 + left_size, pre_r, in_l + 1 + left_size, in_r);

            // 创建当前子树的根节点，并将左、右子树连接上
            return new TreeNode(preorder[pre_l], left, right);
        };

        // 调用 dfs 函数，从整个树的前序和中序遍历范围开始构建
        return dfs(0, n, 0, n); 
    }
};

```

###         b.前序后序

### 	c.中序后序

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        unordered_map<int,int> index;
        int n = inorder.size();
        for(int i = 0;i < n;i++)
        {
            index[inorder[i]] = i;
        }

        function<TreeNode*(int,int,int,int)> dfs = [&](int in_l, int in_r, int po_l, int po_r)->TreeNode*
        {
            if(po_l == po_r) return nullptr;
            int left_size = index[postorder[po_r-1]] - in_l;

            auto left = dfs(in_l, in_l + left_size, po_l, po_l + left_size);
            auto right = dfs(in_l + left_size + 1, in_r, po_l +left_size, po_r-1);
            return new TreeNode(postorder[po_r-1],left,right);
        };

        return dfs(0,n,0,n);
    }
};
```

## 12.树直径问题

链：从下面的某个节点（不一定是叶子）到当前节点的路径。把这条链的节点值之和，作为 dfs 的返回值。如果节点值之和是负数，则返回 0。
直径：等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里「拐弯」，也就是计算由左右两条从下面的某个节点（不一定是叶子）到 node 的链的节点值之和，去更新答案的最大值。

### 543.二叉树的直径

### 124.二叉树中的最大路径和

重点：转折点

![](C:\Users\86138\Desktop\算法\微信图片_20241107194255.jpg)

```cpp
class Solution {
public:
    int maxSum = INT_MIN;
    int maxPathSum(TreeNode* root) {
        
        dfs(root);
        return maxSum;
    }
    int dfs(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int left = dfs(root->left);
        left = max(left, 0); // 分支最大值为负数，则丢弃考虑分支
        int right = dfs(root->right);
        right = max(right, 0);
        // 递归过程进行更新
        maxSum = max(maxSum, root->val + left + right);
        return root->val + max(left, right);
    }
};
```



### 2246.相邻字符不同的最长路径



## 递归大全

### 相同的树

```c++
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        if (p == nullptr || q == nullptr)
            return p == q; // 必须都是 nullptr
        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};


```

### 对称二叉树

```c++
class Solution {
public:
    bool isthesame(TreeNode*p,TreeNode*q)
    {
        if(p==nullptr&&q!=nullptr) return false;
        if(p!=nullptr&&q==nullptr) return false;
        if(p==nullptr&&q==nullptr) return true;
        if(p->val==q->val) 
        {
            return isthesame(p->left,q->right)&&isthesame(p->right,q->left);

        }
        return false;
    }
    
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr) return true;
        return isthesame(root->left,root->right);
    }
};
```

### 平衡二叉树

```c++
class Solution {
    int get_height(TreeNode *node) {
        if (node == nullptr) return 0;
        int leftH = get_height(node->left);
        if (leftH == -1) return -1; // 提前退出，不再递归
        int rightH = get_height(node->right);
        if (rightH == -1 || abs(leftH - rightH) > 1) return -1;
        return max(leftH, rightH) + 1;
    }

public:
    bool isBalanced(TreeNode *root) {
        return get_height(root) != -1;
    }
};
```



# 十一、图论

## 1.岛屿数量

### 方法一 dfs

**把访问过的格子插上旗子**

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int x = grid.size();
        int y = grid[0].size();
        int res = 0;
        function<void(int,int)> dfs = [&](int i,int j)
        {
            grid[i][j] = '0';

            if(i-1>=0 && grid[i-1][j] == '1') dfs(i-1,j);
            if(i+1<x && grid[i+1][j] == '1') dfs(i+1,j);   
            if(j-1>=0 && grid[i][j-1] == '1') dfs(i,j-1);
            if(j+1<y && grid[i][j+1] == '1') dfs(i,j+1);
        };

        for(int i = 0;i < x;i++)
        {
            for(int j = 0;j < y;j++)
            {
                if(grid[i][j] == '1') 
                {
                    dfs(i,j);
                    res++;
                }
            }
        }

        return res;
    }
};
```

### 方法二 bfs

### 方法三 并查集

## 2.腐烂的橘子

### 我的代码：

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int time = 0;              // 用于记录腐烂所有橘子所需的分钟数
        int remain = 0;            // 新鲜橘子数量
        int bad = 0;               // 腐烂橘子数量
        int old_bad = bad;         // 上一轮的腐烂橘子数量，用于检测腐烂数量是否增加
        int m = grid.size();       // 行数
        int n = grid[0].size();    // 列数

        // 定义一个递归 lambda 表达式 `broad`，用于向四周扩散腐烂状态
        function<void(int, int)> broad = [&](int i, int j) {
            // 向上扩散
            if (i - 1 >= 0 && grid[i - 1][j] == 1) {
                grid[i - 1][j] = 3 + time;  // 标记新的腐烂橘子
                remain--;                   // 新鲜橘子数量减少
                bad++;                      // 腐烂橘子数量增加
            }
            // 向下扩散
            if (i + 1 < m && grid[i + 1][j] == 1) {
                grid[i + 1][j] = 3 + time;
                remain--;
                bad++;
            }
            // 向左扩散
            if (j - 1 >= 0 && grid[i][j - 1] == 1) {
                grid[i][j - 1] = 3 + time;
                remain--;
                bad++;
            }
            // 向右扩散
            if (j + 1 < n && grid[i][j + 1] == 1) {
                grid[i][j + 1] = 3 + time;
                remain--;
                bad++;
            }
        };

        // 遍历网格，统计新鲜橘子（1）和腐烂橘子（2）的数量
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1)
                    remain++;
                if (grid[i][j] == 2)
                    bad++;
            }
        }

        // 如果没有新鲜橘子，直接返回 0，因为不需要腐烂时间
        if (remain == 0)
            return 0;

        // 如果没有腐烂橘子且有新鲜橘子，返回 -1，因为无法使新鲜橘子腐烂
        if (bad == 0)
            return -1;

        old_bad = bad;  // 记录初始的腐烂橘子数量

        // 开始模拟腐烂过程
        while (true) {
            // 遍历所有腐烂橘子，调用 `broad` 扩散腐烂
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (grid[i][j] == 2 + time)  // 只对当前时间腐烂的橘子进行扩散
                        broad(i, j);
                }
            }

            // 如果腐烂橘子数量没有变化，说明无法再扩散，返回 -1
            if (old_bad == bad)
                return -1;
            else
                old_bad = bad;  // 更新腐烂橘子数量

            time++;  // 时间加一

            // 如果新鲜橘子数量为 0，返回所需时间
            if (remain == 0)
                return time;
        }

        return -1;  // 不可达的代码，仅为安全性
    }
};
```

```c++
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        int time = -1;
        vector<pair<int, int>> gd;
        function<void(vector<pair<int,int>>&)> dfs = [&](vector<pair<int,int>>& gd) {
            if (gd.empty())
                return;
            time++;
            vector<pair<int, int>> gd2 = gd;
            gd.clear();
            for (auto [i, j] : gd2) {
                grid[i][j] = 0;
                if (i - 1 >= 0 && grid[i - 1][j] == 1) {
                    gd.push_back({i - 1, j});
                    grid[i - 1][j] = 2;
                }
                if (i + 1 < m && grid[i + 1][j] == 1) {
                    gd.push_back({i + 1, j});
                    grid[i + 1][j] = 2;
                }
                if (j - 1 >= 0 && grid[i][j - 1] == 1) {
                    gd.push_back({i, j - 1});
                    grid[i][j - 1] = 2;
                }
                if (j + 1 < n && grid[i][j + 1] == 1) {
                    gd.push_back({i, j + 1});
                    grid[i][j + 1] = 2;
                }
            }
            dfs(gd);
        };
        for (int x = 0; x < m; x++) {
            for (int y = 0; y < n; y++) {
                if (grid[x][y] == 2) {
                    gd.push_back({x, y});
                }
            }
        }
        dfs(gd);
        for(int i = 0;i < m;i++){
            for(int j = 0;j < n;j++){
                if(grid[i][j] == 1) return -1;
            }
        }
        return max(0,time);
    }
};
```



### 多源广度优先搜索（多源bfs)

```cpp
class Solution {
    int DIRECTIONS[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 四方向

public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int fresh = 0;
        vector<pair<int, int>> q;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    fresh++; // 统计新鲜橘子个数
                } else if (grid[i][j] == 2) {
                    q.emplace_back(i, j); // 一开始就腐烂的橘子
                }
            }
        }

        int ans = 0;
        while (fresh && !q.empty()) {
            ans++; // 经过一分钟
            vector<pair<int, int>> nxt;
            for (auto& [x, y] : q) { // 已经腐烂的橘子  //注意这种写法
                for (auto d : DIRECTIONS) { // 四方向
                    int i = x + d[0], j = y + d[1];
                    if (0 <= i && i < m && 0 <= j && j < n && grid[i][j] == 1) { // 新鲜橘子
                        fresh--;
                        grid[i][j] = 2; // 变成腐烂橘子
                        nxt.emplace_back(i, j);
                    }
                }
            }
            q = move(nxt);
        }

        return fresh ? -1 : ans;
    }
};
```

**两种不同：**

**一个每次遍历寻找新腐烂的橘子**

**一个在找到腐烂的橘子同时把新腐烂的橘子存储以便下一次扩散**

**向四个方向扩散写法学习**

### 相似题目 928.尽量减少恶意软件的传播II

## 3.课程表 (拓扑排序)

**给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：**

**对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。**

那么称该排列是图 G 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：

如果图 G 中存在环（即图 G 不是「有向无环图」），那么图 G 不存在拓扑排序。

如果图 G 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 G 值包含 n 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。

```c++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> ans;  // 存储课程学习顺序
        vector<vector<int>> graph(numCourses);  // 邻接表存储课程依赖关系
        vector<int> pre(numCourses, 0);  // 记录每个课程的入度，即需要先修的课程数量
        
        // 构建邻接表（有向图）和入度数组
        for(auto prerequisite : prerequisites){
            int course = prerequisite[0];  // 当前课程
            int prereq = prerequisite[1];  // 先修课程
            
            pre[course]++;  // 课程 course 需要先修课程 prereq，所以入度 +1
            graph[prereq].push_back(course);  // prereq 指向 course，表示修完 prereq 后可修 course
        }

        queue<int> qe;  // 队列存储当前可以学习的课程（即入度为 0 的课程）
        
        // 找到所有没有前置课程的课程（入度为 0）
        for(int i = 0; i < numCourses; i++){
            if(pre[i] == 0) qe.push(i);
        }

        // 进行拓扑排序
        while(!qe.empty()){
            int temp = qe.front();  // 取出一个当前可以学习的课程
            qe.pop();
            ans.push_back(temp);  // 记录学习顺序
            
            // 遍历当前课程的所有后续课程
            for(int nextCourse : graph[temp]){
                pre[nextCourse]--;  // 由于当前课程已学完，后续课程的入度减 1
                if(pre[nextCourse] == 0){  // 如果后续课程入度变为 0，则可以学习
                    qe.push(nextCourse);
                }
            }
        }

        // 如果拓扑排序结果的课程数量等于总课程数，说明可以安排学习，否则说明有环，无法完成所有课程
        return ans.size() == numCourses ? ans : vector<int>();
    }
};

```



# 十二、二分查找(三种二分查找都得熟悉)

\- 核心要素

**关键不在于区间里的元素具有什么性质，而是区间外面的元素具有什么性质**

- 注意区间开闭，三种都可以

- 循环结束条件：当前区间内没有元素 

- 下一次二分查找区间：不能再查找(区间不包含)mid，防止死循环

- 返回值：大于等于target的第一个下标（注意循环不变量）

  

有序数组中二分查找的四种类型（下面的转换仅适用于数组中都是整数） 

- 第一个大于等于x的下标： low_bound(x) 

- 第一个大于x的下标：可以转换为`第一个大于等于 x+1 的下标` ，low_bound(x+1) 

- 最后一个一个小于x的下标：可以转换为`第一个大于等于 x 的下标` 的`左边位置`, low_bound(x) - 1

- 最后一个小于等于x的下标：可以转换为`第一个大于等于 x+1 的下标` 的 `左边位置`, low_bound(x+1) - 1

  ## 注意二分查找的区别
  
  `upper_bound` 和 `lower_bound` 的主要区别在于：
  
  - `lower_bound(nums, target)`: 返回 **第一个** `>= target` 的元素索引（即**大于等于 target** 的最左侧位置）。
  - `upper_bound(nums, target)`: 返回 **第一个** `> target` 的元素索引（即**严格大于 target** 的最左侧位置）。
  
  ```c++
   int lower_bound(vector<int>& nums, int target) {
          int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
          while (left <= right) { // 区间不为空
              // 循环不变量：
              // nums[left-1] < target
              // nums[right+1] >= target
              int mid = left + (right - left) / 2;
              if (nums[mid] < target) {
                  left = mid + 1; // 范围缩小到 [mid+1, right]
              } else {
                  right = mid - 1; // 范围缩小到 [left, mid-1]
              }
          }
          return left;
      }
  
  int upper_bound(vector<int>& nums, int target) {
      int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
      while (left <= right) { // 区间不为空
          int mid = left + (right - left) / 2;
          if (nums[mid] <= target) { // 注意这里是 <=
              left = mid + 1; // 继续查找右侧 [mid+1, right]
          } else {
              right = mid - 1; // 继续查找左侧 [left, mid-1]
          }
      }
      return left;
  }
  
  ```
  
  

## 1.搜索插入位置

**int mid = left + (right - left) / 2;防止溢出**

```cpp
class Solution {
    // lower_bound 返回最小的满足 nums[i] >= target 的 i
    // 如果数组为空，或者所有数都 < target，则返回 nums.size()
    // 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]

    // 闭区间写法
    int lower_bound(vector<int>& nums, int target) {
        int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
        while (left <= right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right+1] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1; // 范围缩小到 [mid+1, right]
            } else {
                right = mid - 1; // 范围缩小到 [left, mid-1]
            }
        }
        return left;
    }

    // 左闭右开区间写法
    int lower_bound2(vector<int>& nums, int target) {
        int left = 0, right = nums.size(); // 左闭右开区间 [left, right)
        while (left < right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1; // 范围缩小到 [mid+1, right)
            } else {
                right = mid; // 范围缩小到 [left, mid)
            }
        }
        return left;
    }

    // 开区间写法
    int lower_bound3(vector<int>& nums, int target) {
        int left = -1, right = nums.size(); // 开区间 (left, right)
        while (left + 1 < right) { // 区间不为空
            // 循环不变量：
            // nums[left] < target
            // nums[right] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid; // 范围缩小到 (mid, right)
            } else {
                right = mid; // 范围缩小到 (left, mid)
            }
        }
        return right;
    }

public:
    int searchInsert(vector<int>& nums, int target) {
        return lower_bound(nums, target); // 选择其中一种写法即可
    }
};
```

## 2.在排序数组中查找元素的第一个和最后一个位置

```cpp
class Solution {
public:
    int lower_bound(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
    vector<int> searchRange(vector<int>& nums, int target) {
        int begin = lower_bound(nums, target);
        if (nums.size() == begin || nums[begin] != target)
            return {-1, -1};
        int end = lower_bound(nums, target + 1);
        return {begin, end - 1};
    }
};
```

## 3.[ 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/by-endlesscheng-owgd/)

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right){
            int mid = (left + right)/2;
            if(nums[mid] >= nums[0]){
                left = mid + 1;
            }
            else{
                right = mid - 1;
            }
        }
        if(right + 1 >= nums.size()) return nums[0];
        return nums[right+1];
    }
};
```



## 4.搜索旋转排序数组

## 方法一  一次二分查找（为什么我想不到？）(数学分段函数问题)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int m = 0;
        int n = nums.size() - 1;

        while(m <= n){
            int mid = (m + n) / 2;
            if(nums[mid] >= nums[0]){
                if(target == nums[mid]) return mid;
                else if(target < nums[mid] && target >= nums[0]){
                   n = mid - 1;
                }
                else {
                    m = mid + 1;
                }
            } else {
                if(target == nums[mid]) return mid;
                if(target >= nums[mid] && target < nums[0]){
                    m = mid + 1;
                } else {
                    n = mid -1;
                }
            }

        }
        return -1;
    }
};
```



## 方法二  两次二分查找	



## **5.寻找两个正序数组的中位数

```markdown
### 问题概述

我们有两个有序数组 `nums1` 和 `nums2`，需要找到它们合并后的中位数。合并排序的常规方法是 O(m + n) 的时间复杂度，但在这种情况下，可以通过二分查找降低到 **O(log(min(m, n)))**。

### 核心思想：分割两数组，找到中位数位置

#### 1. 理解“中位数”在有序数组中的位置

对于一个数组，**中位数是中间位置的元素**：
- 若数组长度为奇数，中位数是正中间的元素。
- 若数组长度为偶数，中位数是中间两个元素的平均值。

在两个数组的总长度是 `totalLength = m + n` 的情况下：
- 若 `totalLength` 为奇数，则中位数是合并后数组第 `totalLength / 2 + 1` 小的元素。
- 若 `totalLength` 为偶数，则中位数是第 `totalLength / 2` 和第 `totalLength / 2 + 1` 小的元素的平均值。

#### 2. 寻找“分割点”来保证两部分平衡

为了找到中位数，我们不必真正合并数组，而是通过“分割”的方式来在逻辑上确定中间位置。设想将两个数组分割成两部分，使得左侧部分的所有元素都小于右侧部分的所有元素，并且**左侧和右侧的元素数量尽可能相等**。

举个例子：
- 假设 `nums1` 和 `nums2` 的总长度是 9（奇数）。则左侧部分包含 5 个元素，右侧部分包含 4 个元素。
- 假设 `nums1` 和 `nums2` 的总长度是 8（偶数）。则左右各包含 4 个元素。

通过这样的分割，我们可以利用左侧的最大元素和右侧的最小元素来直接得到中位数。

#### 3. 定义两个数组的分割位置

我们定义两个数组 `nums1` 和 `nums2` 的分割位置为 `partition1` 和 `partition2`。这样：
- `partition1` 左边的所有元素属于“左侧部分”；
- `partition2` 左边的所有元素也属于“左侧部分”。

我们希望这两个分割点满足以下条件：
- 左侧部分的元素总数等于右侧部分的元素总数（或者在奇数长度下，左侧比右侧多一个元素）。
- 左侧的最大值小于等于右侧的最小值，即 `maxLeft1 <= minRight2` 且 `maxLeft2 <= minRight1`。

#### 4. 通过二分查找寻找分割位置

为了高效地找到分割点，我们对较短的数组 `nums1` 进行二分查找：
- 选择 `nums1` 的某个位置 `partition1` 将其分为左、右两部分。
- 确定 `partition2 = (halfLength - partition1)` 以保证左右两部分元素数量接近平衡。

在每一步检查：
- 若满足 `maxLeft1 <= minRight2` 且 `maxLeft2 <= minRight1`，则找到了合适的分割位置，可以计算中位数。
- 如果 `maxLeft1 > minRight2`，说明 `partition1` 选得太大，`partition1` 左移。
- 如果 `maxLeft2 > minRight1`，说明 `partition1` 选得太小，`partition1` 右移。

### 中位数的计算

一旦找到合适的分割点：
- 如果总长度 `totalLength` 为奇数，中位数为左侧的最大值 `max(maxLeft1, maxLeft2)`。
- 如果 `totalLength` 为偶数，中位数为左侧最大值和右侧最小值的平均值，即 `(max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0`。

### 总结

这个算法的关键在于：
1. 利用二分查找的方式确定分割位置。
2. 通过两个分割点将两个有序数组逻辑上分成“左侧”和“右侧”，使得只需在两数组的一部分范围内确定中位数位置，降低了时间复杂度。
3. 利用分割后的左侧最大值和右侧最小值，直接确定中位数的值，而不需实际合并数组。
```

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int len1 = nums1.size();
        int len2 = nums2.size();

        // 保证 len1 <= len2，这样我们只对较短数组进行二分
        if (len1 > len2) {
            return findMedianSortedArrays(nums2, nums1);
        }

        int totalLength = len1 + len2;
        int halfLength = (totalLength + 1) / 2;  // 中位数位置

        int left = 0, right = len1;
        while (left <= right) {
            int partition1 = (left + right) / 2;
            int partition2 = halfLength - partition1;

            int maxLeft1 = (partition1 == 0) ? INT_MIN : nums1[partition1 - 1];
            int minRight1 = (partition1 == len1) ? INT_MAX : nums1[partition1];

            int maxLeft2 = (partition2 == 0) ? INT_MIN : nums2[partition2 - 1];
            int minRight2 = (partition2 == len2) ? INT_MAX : nums2[partition2];

            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {
                // 找到合适的分割
                if (totalLength % 2 == 0) {
                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0;
                } else {
                    return max(maxLeft1, maxLeft2);
                }
            } else if (maxLeft1 > minRight2) {
                // 说明 partition1 需要左移
                right = partition1 - 1;
            } else {
                // 说明 partition1 需要右移
                left = partition1 + 1;
            }
        }

        throw invalid_argument("Input arrays are not sorted.");
    }
};

```



# 十三、排除法

## 1.搜索二维矩阵

最优解（二分查找）O(logmn)

排除法：

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int i = 0, j = n - 1;
        while (i < m && j >= 0) { // 还有剩余元素
            if (matrix[i][j] == target) {
                return true; // 找到 target
            }
            if (matrix[i][j] < target) {
                i++; // 这一行剩余元素全部小于 target，排除
            } else {
                j--; // 这一列剩余元素全部大于 target，排除
            }
        }
        return false;
    }
};
```

- 时间复杂度：O(*m*+*n*)，其中 *m* 和 *n* 分别为 *matrix* 的行数和列数。
- 空间复杂度：O(1)。****

## 2.[ 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)。

# 十四、栈

## 1.有效的括号

```cpp
class Solution {
    unordered_map<char, char> mp = {{')', '('}, {']', '['}, {'}', '{'}};
public:
    bool isValid(string s) {
        if (s.length() % 2) { // s 长度必须是偶数
            return false;
        }
        stack<char> st;
        for (char c : s) {
            if (!mp.contains(c)) { // c 是左括号
                st.push(c); // 入栈
            } else { // c 是右括号
                if (st.empty() || st.top() != mp[c]) {
                    return false; // 没有左括号，或者左括号类型不对
                }
                st.pop(); // 出栈
            }
        }
        return st.empty(); // 所有左括号必须匹配完毕
    }
};

//使用map利用空间换取代码可维护性
```

## 2.最小栈

### 使用链表

```cpp
class MinStack {
public:
    class Node{
    public:
        int val;
        int min;
        Node* next;
        Node(int val_ , int min_) : val(val_),min(min_),next(nullptr){}
    };
    Node* node;
    MinStack() {
        node = nullptr;
    }
    
    void push(int val) {
        if(node == nullptr){
            node = new Node(val,val);
        } else {
            Node* cur = new Node(val,min(node->min,val));
            cur->next = node;
            node = cur;
        }
    }
    
    void pop() {
        Node* temp = node;
        node = node->next;
        delete temp;
    }
    
    int top() {
        return node->val;
    }
    
    int getMin() {
        return node->min;
    }
};
```

### 使用辅助栈

```cpp
class MinStack {
    stack<pair<int, int>> st;

public:
    MinStack() {
        // 添加栈底哨兵 INT_MAX
        // 这里的 0 写成任意数都可以，反正用不到
        st.emplace(0, INT_MAX);
    }

    void push(int val) {
        st.emplace(val, min(getMin(), val)); 
    }

    void pop() {
        st.pop();
    }

    int top() {
        return st.top().first;
    }

    int getMin() {
        return st.top().second;
    }
};
```



```
`st.push(pair(0,INT_MAX));` 和 `st.emplace(0, INT_MAX);` 这两个方法的不同主要体现在其内部实现机制和性能优化上。以下是它们的详细区别：

---

### 1. **调用方式与内部行为**

- **`push`**
  - `push` 方法需要一个已经构造好的对象作为参数。
  - 在 `st.push(pair(0, INT_MAX))` 中，`pair(0, INT_MAX)` 会先调用 `std::make_pair` 或构造函数创建一个临时的 `std::pair` 对象。
  - 然后将这个临时对象拷贝（或移动，如果可能）到容器中。

- **`emplace`**
  - `emplace` 方法直接在容器的内部构造对象。
  - 在 `st.emplace(0, INT_MAX)` 中，`std::pair` 的构造函数直接在栈内被调用，从而避免了额外的临时对象的创建和拷贝/移动。

---

### 2. **性能差异**

- `push` 可能涉及：
  1. **对象构造**：先在调用 `push` 的地方构造一个临时对象。
  2. **对象拷贝/移动**：将构造好的临时对象拷贝或移动到容器中。

- `emplace` 只涉及：
  1. **对象原地构造**：直接在栈或容器内调用构造函数。

因此，`emplace` 可以避免一次额外的构造和拷贝/移动操作，在性能上通常优于 `push`。

---

### 3. **适用场景**

- **`push`**：
  - 更适合用于已经有一个现成的对象时，例如：
    ```cpp
    std::pair<int, int> p(0, INT_MAX);
    st.push(p);
```
  - 如果直接使用 `pair(0, INT_MAX)`，性能上略逊于 `emplace`。

- **`emplace`**：
  - 更适合直接在容器中构造对象，尤其是需要传递构造函数参数时，例如：
    ```cpp
    st.emplace(0, INT_MAX);
    ```
  - 避免了临时对象的创建和拷贝/移动。

---

**总结**

| 方法       | 是否构造临时对象 | 是否涉及拷贝/移动 | 性能 |
|------------|------------------|------------------|------|
| `push`     | 是               | 是               | 较慢 |
| `emplace`  | 否               | 否               | 较快 |

**结论：**
在你的例子中，如果只需要构造临时对象并直接插入容器，推荐使用 `emplace`，因为它更高效。
```

### 不使用额外空间

```cpp
class MinStack {
private:
    std::stack<long long> st;
    long long minValue; // 用于记录当前最小值

public:
    MinStack() : minValue(0) {}

    void push(int val) {
        if (st.empty()) {
            st.push(0);         // 计算差值
            minValue = val;     // 更新最小值
        } else {
            st.push((long long)val - minValue); // 保存差值
            if (val < minValue) {
                minValue = val; // 更新最小值
            }
        }
    }

    void pop() {
        if (st.empty()) return;

        long long diff = st.top();
        st.pop();

        if (diff < 0) {
            // 弹出的是一个小于0的差值，恢复上一个最小值
            minValue -= diff; // 恢复到上一个最小值
        }
    }

    int top() {
        long long diff = st.top();
        if (diff > 0) {
            return diff + minValue; // 当前值 = 最小值 + 差值
        } else {
            return minValue; // 当前值就是最小值
        }
    }

    int getMin() {
        return minValue;
    }
};
```

## 3.字符串解码

### 方法一  双栈



### 方法二  单栈

```cpp
class Solution {
public:
    string decodeString(string s) {
        stack<pair<int,string>> stk;
        string ch = "";
        int nums = 0;
        for(char c : s){
            if(c>='0'&&c<='9'){
                nums = nums*10 + c -'0';
            }
            else if((c>='a' && c<='z') || (c>='A' && c<='Z')){
                ch = ch + c;
            }
            else if(c == '['){
                stk.emplace(nums,ch);
                ch = "";
                nums = 0;
            }
            else if(c == ']'){
                int num = stk.top().first - 1;
                string temp = ch;
                while(num--){
                    ch = ch + temp;
                }
                ch = stk.top().second + ch;
                stk.pop();
            }
        }
        return ch;
    }
};
```



### 方法三  递归

```cpp
class Solution {
public:
    string decodeString(string s) {
        int i = 0; // 当前s字符串遍历位置
        auto help = [&](auto &&help) -> string { // lambda
            int k = 0;  // 用于存储重复次数
            string res = "";
            while (i < s.length()) {
                char ch = s[i++]; // 取当前字符，并跳到下一个字符
                if (isdigit(ch)) {
                    k = k * 10 + (ch - '0');
                } else if (ch == '[') { 
                    auto sub = help(help);  // 递归解码
                    while (k--) res += sub;
                    k = 0;  // 重置 k（感觉没必要这句，但是不知道为什么在力扣上，少了这句过不去，在自己的电脑上少了这句又没问题）
                } else if (ch == ']') {
                    return res; // 返回结果到上一层递归
                } else res += ch;
            }
            return res;
        };
        return help(help);
    }
};
```

## 4.单调栈

**在一维数组中对每一个数找到第一个比自己小的元素。这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。**

### 739.每日温度

**从左到右：**

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st;
        int n =temperatures.size();
        vector<int> res(n,0);
        for(int i = 0;i < n;i++){
            while(!st.empty() &&temperatures[i] > temperatures[st.top()] ){
                int temp = st.top();
                res[temp] = i - temp;
                st.pop();     
            }
            st.push(i);
        }
        return res;
    }
};
```

**从右到左：**

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int> &temperatures) {
        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> st;
        for (int i = n - 1; i >= 0; i--) {
            int t = temperatures[i];
            while (!st.empty() && t >= temperatures[st.top()]) {
                st.pop();
            }
            if (!st.empty()) {
                ans[i] = st.top() - i;
            }
            st.push(i);
        }
        return ans;
    }
};
```

### 42.接雨水

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> st;
        int ans = 0;
        int n =height.size();

        for(int i = 0; i < n; i++){
            while(!st.empty() && height[i] > height[st.top()]){
                int mid = st.top();
                st.pop();
                if(!st.empty()){
                int left = st.top();
                ans = ans + (i-left-1) * (min(height[i],height[left]) - height[mid]);
                }
            }
            st.push(i);
        }
        return ans;
    }
};
```

### **84.柱状图中的最大矩形(自己写一遍才能感觉到)

我的代码：

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();

        stack<int> st_l;
        vector<int> left(n,-1);//这里的初始化要保证边界
        for(int i = 0;i < n;i++){
 			// < 还是 > 还是 = 要认真考虑
            while(!st_l.empty() && heights[i] <= heights[st_l.top()]){
                st_l.pop();
            }
            if(!st_l.empty()) left[i] = st_l.top();
            st_l.push(i);
        }

        stack<int> st_r;
        vector<int> right(n,n);//这里的初始化要保证边界
        for(int i = n-1;i>=0;i--){
 			// < 还是 > 还是 = 要认真考虑
            while(!st_r.empty() && heights[i] <= heights[st_r.top()]){
                st_r.pop();
            }
            if(!st_r.empty()) right[i] = st_r.top();
            st_r.push(i);
        }

        int ans = 0;
        for(int i = 0;i < n;i++){
            ans = max(ans,heights[i]*(right[i]-left[i]-1));
        }
        return ans;
    }
};
```



#### 两个单调栈

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int> &heights) {
        int n = heights.size();
        vector<int> left(n, -1);
        stack<int> st;
        for (int i = 0; i < n; i++) {
            while (!st.empty() && heights[i] <= heights[st.top()]) {
                st.pop();
            }
            if (!st.empty()) {
                left[i] = st.top();
            }
            st.push(i);
        }

        vector<int> right(n, n);
        st = stack<int>();
        for (int i = n - 1; i >= 0; i--) {
             // < 还是 > 还是 = 要认真考虑
            while (!st.empty() && heights[i] <= heights[st.top()]) {
                st.pop();
            }
            if (!st.empty()) {
                right[i] = st.top();
            }
            st.push(i);
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, heights[i] * (right[i] - left[i] - 1));
        }
        return ans;
    }
};
```



#### 一个单调栈(非常妙)

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights)
{
    int ans = 0;
    stack<int> st;
    heights.insert(heights.begin(), 0);
    heights.push_back(0);
    for (int i = 0; i < heights.size(); i++)
    {
        while (!st.empty() && heights[st.top()] > heights[i])
        {
            int cur = st.top();
            st.pop();
            int left = st.top() + 1;
            int right = i - 1;
            ans = max(ans, (right - left + 1) * heights[cur]);
        }
        st.push(i);
    }
    return ans;
}
};
```

## 5.最长有效括号(栈)

### 栈

1. 遇到右括号竟然不是先判断栈内有没有元素，而是先弹栈再判断（原因是事先入栈了一个分隔元素）
2. 竟然是边入栈边更新长度的，而不是碰到下一个分隔符后，计算两个分隔符之间的差距
3. 每次更新的长度是最近一对括号的长度，而不是一组连续有效括号的长度

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        st.push(-1);
        int ans = 0;
        for(int i = 0;i < s.size();i++){
            if(s[i] == '('){
                st.push(i);
            }
            else {
                st.pop();
                if(st.empty()){
                    st.push(i);
                }
                else {
                    ans = max(ans,i - st.top());
                }
            }
        }
        return ans;
    }
};
```

### 双遍历

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int maxLen = 0, left = 0, right = 0;

        // 左 -> 右 遍历
        for (char c : s) {
            if (c == '(')
                left++;
            else
                right++;
            if (left == right)
                maxLen = max(maxLen, 2 * right);
            if (right > left)
                left = right = 0; // ')' 过多，重置
        }

        left = right = 0;
        // 右 -> 左 遍历
        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] == '(')
                left++;
            else
                right++;
            if (left == right)
                maxLen = max(maxLen, 2 * left);
            if (left > right)
                left = right = 0; // '(' 过多，重置
        }

        return maxLen;
    }
};
```



# 十五、异或运算

异或运算有一个重要的性质：`a ^ a = 0` 和 `a ^ 0 = a`。这意味着，如果我们对数组中的所有元素进行异或运算，所有出现两次的数字会相互抵消，最终剩下的就是那个只出现一次的数字。

## 1.找单独的数（MarsCode)

# 十六、排序问题

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5ef7979ec57eaf418990d19174ca986a.png)

## 快速排序 双路快排 三路快排

## 堆排序：STL和自己实现大根堆和小根堆

## 桶排序

## 1.数组中的第k个最大元素

### 方法一：基于快速选择方法

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        return selectNum(nums,k);
    }

    int selectNum(vector<int>& nums, int k){
        int pos_num = nums[rand() % nums.size()];
        vector<int> big,small,equal;

        for(int num : nums){
            if(num < pos_num) small.push_back(num);
            if(num > pos_num) big.push_back(num);
            if(num == pos_num) equal.push_back(num);
        }

        if(k <= big.size()){
            return selectNum(big,k);
        }
        if(k > big.size() && k> big.size()+equal.size()){
            return selectNum(small, k - big.size() - equal.size());
        }
        return pos_num;
    }
};
```



### 方法二：基于堆排序的选择方法

```cpp
int findKthLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<int>> minHeap; // 小顶堆
    for (int num : nums) {
        minHeap.push(num);
        if (minHeap.size() > k) { // 堆中仅保留 k 个最大元素
            minHeap.pop();
        }
    }
    return minHeap.top(); // 堆顶是第 k 大的元素
}
```



### 方法三：桶排序

```cpp
int findKthLargest(vector<int>& nums, int k) {
    int maxVal = *max_element(nums.begin(), nums.end());
    int minVal = *min_element(nums.begin(), nums.end());
    int bucketSize = maxVal - minVal + 1;

    vector<int> bucket(bucketSize, 0);

    // 统计每个数字出现的次数
    for (int num : nums) {
        bucket[num - minVal]++;
    }

    // 从大到小遍历桶，找到第 k 大的元素
    for (int i = bucketSize - 1; i >= 0; i--) {
        if (bucket[i] > 0) {
            k -= bucket[i];
            if (k <= 0) {
                return i + minVal;
            }
        }
    }
    return -1; // 不会到达这里
}
```

## 2.前K个高频元素

**利用堆**

```c++
class Solution {
public:
    class tmp{
    public:
        bool operator()(const pair<int,int>& p1,const pair<int,int>& p2){
            //return p1.second < p2.second;
            return p1.second > p2.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> mp;
        for(int num : nums)
        {
            mp[num]++;
        }
        priority_queue<pair<int,int>,vector<pair<int,int>>,tmp> qe;
        /*for(auto i = mp.begin();i != mp.end();i++){
            qe.push({i->first,i->second});
        }  时间复杂度  nlogn */

        //时间复杂度 nlogk
        //也可以for(auto& [m,n] : mp)
        for(auto n : mp){
            if(qe.size() == k){
                if(n.second > qe.top().second){
                    qe.pop();
                    qe.push({n.first,n.second});
                }
            }
            else {
                qe.push({n.first,n.second});
            }
            
        }
        vector<int> res;
        while(!qe.empty()){
            res.push_back(qe.top().first);
            qe.pop();
        }
        /*for(int i = 0; i < k;i++){
            res.push_back(qe.top().first);
            qe.pop();
        }*/
        return res;
    }
};
```

# 3.数据流中的中位数（中位数利用两个大小堆）

我的写法(未利用堆来比较顶端元素 分类讨论较复杂)

```cpp
class MedianFinder {
public:
    MedianFinder() {}

    void addNum(int num) {
        if (size_b == size_s) {
            if (size_b != 0 && num > small.top()) {
                int tep = small.top();
                small.pop();
                small.push(num);
                big.push(tep);
                size_b++;
            } else {
                big.push(num);
                size_b++;
            }
        } else {
            if (num <= big.top()) {
                int tmp = big.top();
                big.pop();
                big.push(num);
                small.push(tmp);
                size_s++;
            } else {
                small.push(num);
                size_s++;
            }
        }
    }

    double findMedian() {
        return (size_b + size_s) % 2 == 0 ? (big.top() + small.top()) / 2.0
                                          : big.top();
    }
    priority_queue<int, vector<int>, less<int>> big;
    int size_b = 0;
    priority_queue<int, vector<int>, greater<int>> small;
    int size_s = 0;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

### 最优写法  充分利用堆的排序性质

```c++
class MedianFinder {
    priority_queue<int> left; // 最大堆
    priority_queue<int, vector<int>, greater<>> right; // 最小堆

public:
    void addNum(int num) {
        if (left.size() == right.size()) {
            right.push(num);
            left.push(right.top());
            right.pop();
        } else {
            left.push(num);
            right.push(left.top());
            left.pop();
        }
    }

    double findMedian() {
        if (left.size() > right.size()) {
            return left.top();
        }
        return (left.top() + right.top()) / 2.0;
    }
};
```



# 十七、字符串

## 3.数字字符串格式化

**问题描述**

小M在工作时遇到了一个问题，他需要将用户输入的不带千分位逗号的数字字符串转换为带千分位逗号的格式，并且保留小数部分。小M还发现，有时候输入的数字字符串前面会有无用的 `0`，这些也需要精简掉。请你帮助小M编写程序，完成这个任务。

------

**测试样例**

***样例1：***

> 输入：`s = "1294512.12412"`
> 输出：`'1,294,512.12412'`

***样例2：***

> 输入：`s = "0000123456789.99"`
> 输出：`'123,456,789.99'`

***样例3：***

> 输入：`s = "987654321"`
> 输出：`'987,654,321'`



```c++
std::string solution(const std::string& s){
    std::string str = s;
    
    //删除前置0
    str.erase(0,str.find_first_not_of('0'));
    if(s.empty()) str = "0";

    size_t pos = str.find('.');
    
    //分出小数和整数
    std::string int_part = str.substr(0,pos);
    std::string dec_part = (pos != std::string::npos ? str.substr(pos+1) : "");

    int index = 0;
    //添加逗号
    /*size_t i = int_part.size() - 1; i >= 0; i-- 是不正确的，
    因为 i 是 size_t 类型（无符号类型），在 i 为 0 时减去 1 会导致发生下溢，变为非常大的值。可以改为：*/
    for(int i = int_part.size()-1;i >= 0;i--){
        index = (++index)%3;
        if(index == 0 && i !=0) {
            int_part.insert(i,",");
        }
    }

    return dec_part != "" ? int_part + '.' +dec_part : int_part ;

}
```

# 十八、正则表达式

在广告平台中，为了给广告主一定的自由性和效率，允许广告主在创造标题的时候以通配符的方式进行创意提交。线上服务的时候，会根据用户的搜索词触发的 bidword 对创意中的通配符（通配符是用成对 {} 括起来的字符串，可以包含 0 个或者多个字符）进行替换，用来提升广告投放体验。例如：“{末日血战} 上线送 SSR 英雄，三天集齐无敌阵容！”，会被替换成“帝国时代游戏下载上线送 SSR 英雄，三天集齐无敌阵容！”。给定一个含有通配符的创意和n个标题，判断这句标题是否从该创意替换生成的。

------

测试样例

***样例1：***

> 输入：`n = 4, template = "ad{xyz}cdc{y}f{x}e", titles = ["adcdcefdfeffe", "adcdcefdfeff", "dcdcefdfeffe", "adcdcfe"]`
> 输出：`"True,False,False,True"`

***样例2：***

> 输入：`n = 3, template = "a{bdc}efg", titles = ["abcdefg", "abefg", "efg"]`
> 输出：`"True,True,False"`

***样例3：***

> 输入：`n = 5, template = "{abc}xyz{def}", titles = ["xyzdef", "abcdef", "abxyzdef", "xyz", "abxyz"]`
> 输出：`"True,False,True,True,True"`

```c++
#include <iostream>
#include <regex>
#include <string>
#include <vector>

std::string solution(int n, const std::string& template_, const std::vector<std::string>& titles) {
    // 将模板转换为正则表达式
    std::string pattern = std::regex_replace(template_, std::regex("\\{[^}]*\\}"), ".*");
    std::string res;

// 对每个标题进行匹配
for (const auto& title : titles) {
    if (std::regex_match(title, std::regex("^" + pattern + "$"))) {
        res += (res.empty() ? "True" : ",True");
    } else {
        res += (res.empty() ? "False" : ",False");
    }
}
return res;

}

int main() {
    std::vector<std::string> testTitles1 = {"adcdcefdfeffe", "adcdcefdfeff", "dcdcefdfeffe", "adcdcfe"};
    std::vector<std::string> testTitles2 = {
        "CLSomGhcQNvFuzENTAMLCqxBdj", "CLSomNvFuXTASzENTAMLCqxBdj",
        "CLSomFuXTASzExBdj", "CLSoQNvFuMLCqxBdj",
        "SovFuXTASzENTAMLCq", "mGhcQNvFuXTASzENTAMLCqx"};
    std::vector<std::string> testTitles3 = {"abcdefg", "abefg", "efg"};

std::cout << (solution(4, "ad{xyz}cdc{y}f{x}e", testTitles1) == "True,False,False,True") << std::endl;
std::cout << (solution(6, "{xxx}h{cQ}N{vF}u{XTA}S{NTA}MLCq{yyy}", testTitles2) ==
              "False,False,False,False,False,True")
          << std::endl;
std::cout << (solution(3, "a{bdc}efg", testTitles3) == "True,True,False") << std::endl;

return 0;

}
```

# 十九、贪心算法

## 跳跃游戏1 2  见leetcode

## 1.灌溉花园的最小水龙头数目(和跳跃游戏II一样)(建桥问题)

**将每个水龙头点上的问题 转换为区间段上的问题**

```c++
class Solution {
public:
    int minTaps(int n, vector<int>& ranges) {
        //将水龙头点的问题转化为区间段问题
        vector<int> max_right(n+1,0);
        for(int i = 0; i <= n;i++){
            //if(ranges[i] == 0) continue;
            int left = max(i - ranges[i], 0);
            int right = min(i + ranges[i], n);
            max_right[left] = max(max_right[left], right);
        }

        int num = 0;
        int pos = 0;
        int next_pos = 0;
        for(int i = 0;i < n;i++){
            next_pos = max(next_pos,max_right[i]);
            if(i == pos){
                if(i == next_pos) return -1;
                pos = next_pos;
                num++;
            }
        }
        return num;
    }
};
```

## 2.视频拼接

```cpp
class Solution {
public:
    int videoStitching(vector<vector<int>>& clips, int time) {
        vector<int> rightMax(time + 1, 0);
        for(int i = 0;i < clips.size();i++){
            if(clips[i][0] < time)
            rightMax[clips[i][0]] = max(rightMax[clips[i][0]],clips[i][1]);
        }
        int num = 0;
        int pos = 0;
        int next_pos = 0;
        for(int i = 0;i < time;i++){
            next_pos = max(next_pos,rightMax[i]);
            if(pos == i){
                if(i == next_pos) return -1;
                pos = next_pos;
                num++;
            }
        }
        return num;
    }
};
```

## 3.划分字母区间

**类似于合并区间端点问题  贪心算法**

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int max_right = 0;
        int pos = 0;
        vector<int> result;
        for(int i = 0;i < s.size();i++){
            max_right = max(max_right,(int)s.find_last_of(s[i]));
            if(i == max_right){
                result.push_back(i - pos + 1);
                pos = max_right + 1;
            }
        }
        return result;
    }
};
```

## 4.合并区间

```c++
class Solution {
public:
    // struct sortinter{
    //     bool operator()(const vector<int>& n1 ,const vector<int>& n2){
    //         return n2[0] > n1[0];
    //     }
    // };
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        //排序默认按第一个元素从小到大
        sort(intervals.begin(),intervals.end());
        int left = intervals[0][0];
        int right = intervals[0][1];
        vector<vector<int>> res;
        for(int i = 0; i < intervals.size(); i++){
            if(intervals[i][0] <= right) right = max(right,intervals[i][1]);
            else {
                res.push_back({left,right});
                left = intervals[i][0];
                right = intervals[i][1];
            }
            if(i == intervals.size() - 1) res.push_back({left,right});
        }
        return res;
    }
};
```

## 



# 二十、回溯(通常用到递归)

[总结了回溯问题类型，带你搞懂回溯算法](https://leetcode.cn/problems/subsets/solutions/229569/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/?envType=study-plan-v2&envId=top-100-liked)

**回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：**

**找到一个可能存在的正确的答案；**
**在尝试了所有可能的分步方法后宣告该问题没有答案。**

## 分为三种类型：子集、组合      排列       搜索

## 回溯也有不同写法

**在递归函数中**

**1.只有最后if(index == nums.size()) res.push_back(current)   +  不含for循环**

**2.每次res.push_back()  +  含for循环**



# 递归时变化的量通常直接作为递归函数的参数，这样方便回溯



## 1.电话号码的字母组合(组合)

```c++
// 回溯函数
void backtrack(const string &digits, const vector<string> &mapping, int index, string &current, vector<string> &result) {
    // 如果当前组合长度等于输入数字长度，加入结果
    if (index == digits.size()) {
        result.push_back(current);
        return;
    }

    // 当前数字对应的字母集
    string letters = mapping[digits[index] - '0'];
    for (char letter : letters) {
        current.push_back(letter);    // 选择当前字母
        backtrack(digits, mapping, index + 1, current, result); // 递归
        current.pop_back();           // 撤销选择
    }
}

vector<string> letterCombinations(string digits) {
    if (digits.empty()) return {};  // 输入为空的边界情况

    // 数字到字母的映射表，0和1对应空字符串
    vector<string> mapping = {
        "", "", "abc", "def", "ghi", "jkl", 
        "mno", "pqrs", "tuv", "wxyz"
    };

    vector<string> result;  // 存放结果
    string current;         // 当前路径
    backtrack(digits, mapping, 0, current, result);
    return result;
}
```

## 2.全排列(排列)

### 在上一题基础上传参优化

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        dfs(nums, 0);
        return res;
    }
private:
    vector<vector<int>> res;
    void dfs(vector<int> nums, int x) {
        if (x == nums.size() - 1) {
            res.push_back(nums);      // 添加排列方案
            return;
        }
        for (int i = x; i < nums.size(); i++) {
            swap(nums[i], nums[x]);   // 交换，将 nums[i] 固定在第 x 位
            dfs(nums, x + 1);         // 开启固定第 x + 1 位元素
            swap(nums[i], nums[x]);   // 恢复交换
        }
    }
};
```

# 3.子集(子集)

### 与上面两题有点不同之处

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> current;
	void runback(vector<int> nums, int index) {
    	if(index == nums.size()) {  // 递归终止条件：到达数组末尾
        	res.push_back(current); // 将当前路径生成的子集加入结果集
        	return;                 // 结束当前递归
    	}

    	// 选择当前元素，加入当前路径
    	current.push_back(nums[index]);
    	runback(nums, index + 1);   // 递归处理下一个元素
    	current.pop_back();         // 回溯：移除当前元素

   	 	// 不选择当前元素，直接递归处理下一个元素
    	runback(nums, index + 1);
	}

    vector<vector<int>> subsets(vector<int>& nums) {
        runback(nums,0);
        return res;
    }
};
```

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> ans;
        vector<int> path;
        int n = nums.size();
        auto dfs = [&](this auto&& dfs, int i) -> void {
            ans.emplace_back(path);
            for (int j = i; j < n; j++) { // 枚举选择的数字
                path.push_back(nums[j]);
                dfs(j + 1);
                path.pop_back(); // 恢复现场
            }
        };
        dfs(0);
        return ans;
    }
};
```

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> ans(1 << n);
        for (int i = 0; i < (1 << n); i++) { // 枚举全集 U 的所有子集 i
            for (int j = 0; j < n; j++) {
                if (i >> j & 1) { // j 在集合 i 中
                    ans[i].push_back(nums[j]);
                }
            }
        }
        return ans;
    }
};
```

## 4.子集II(子集)

在不选 nums[i] 时，要跳过后续所有等于 nums[i] 的数。如果不跳过这些数，

设 x=nums[i], x ′=nums[i+1]，那么「选 x 不选 x ′ 」和「不选 x 选 x ′ 」这两种情况都会加到答案中，这就重复了。

## 去重需要排序

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> current;
    void runback(vector<int>& nums,int index){
        if(index == nums.size()){
            res.push_back(current);
            return;   
        }
        current.push_back(nums[index]);
        runback(nums,index+1);
        current.pop_back();
        while(index + 1 < nums.size() && nums[index + 1] == nums[index]){
            index++;
        }
        runback(nums,index+1);
        return;
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        runback(nums,0);
        return res;
    }
};
```

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> current;

    void runback(vector<int>& nums, int index) {
        res.emplace_back(current); // 每个节点的状态都可以构成一个子集
        for (int i = index; i < nums.size(); ++i) {
            // 跳过同一层的重复元素
            if (i > index && nums[i] == nums[i - 1]) continue;

            current.push_back(nums[i]);
            runback(nums, i + 1);
            current.pop_back();
        }
    }

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end()); // 排序以方便去重
        runback(nums, 0);
        return res;
    }
};

```

## 5.组合总和

```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> current;
        int sum = 0;
        function<void(int)> runback = [&](int index){
            if(sum == target) {
                res.push_back(current);
                return;
            }
            if(index >= candidates.size() || sum > target) return;
            
            runback(index+1);
            sum += candidates[index];
            current.push_back(candidates[index]);
            runback(index);
            //下面这句会重复
            //runback(index+1);  
            
            sum -= candidates[index];
            current.pop_back();
        };
        runback(0);
        return res;
    }
};
```

## 6.括号生成

```c++
class Solution {
public:
    string current;
    vector<string> res;
    void backtrack(int open, int close ,int& n){
        if(current.size() == n * 2){
            res.push_back(current);
            return;
        }
        if(open < n){
            current.push_back('(');
            backtrack(open+1,close,n);
            current.pop_back();
        }
        if(close < open){
            current.push_back(')');
            backtrack(open,close+1,n);
            current.pop_back();
        }
    }
    vector<string> generateParenthesis(int n) {
        backtrack(0,0,n);
        return res;
    }
};
```

## 7.单词搜索(搜索)

**方法一  利用临时标记**

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int rows = board.size();
        int cols = board[0].size();
        
        // 辅助函数：深度优先搜索
        function<bool(int, int, int)> dfs = [&](int row, int col, int index) -> bool {
            // 如果匹配到单词的所有字符
            if (index == word.size()) return true;
            // 如果越界或字符不匹配
            if (row < 0 || row >= rows || col < 0 || col >= cols || board[row][col] != word[index]) 
                return false;
            
            // 临时标记当前单元格为访问过
            char temp = board[row][col];
            board[row][col] = '#';
            
            // 搜索四个方向
            bool found = dfs(row + 1, col, index + 1) ||
                         dfs(row - 1, col, index + 1) ||
                         dfs(row, col + 1, index + 1) ||
                         dfs(row, col - 1, index + 1);
            
            // 回溯：恢复单元格的原始状态
            board[row][col] = temp;
            
            return found;
        };
        
        // 遍历每个单元格作为起点
        for (int r = 0; r < rows; ++r) {
            for (int c = 0; c < cols; ++c) {
                if (dfs(r, c, 0)) return true; // 从当前位置开始搜索
            }
        }
        
        return false; // 未找到单词
    }
};
```

## 8.分割回文串

```c++
class Solution {
public:
    bool isPalindrome(string &s, int left, int right) {
        while (left < right) {
            if (s[left] != s[right]) return false;
            left++;
            right--;
        }
        return true;
    }

    vector<vector<string>> partition(string s) {
        vector<vector<string>> res;
        vector<string> current;
        
        function<void(int)> dfs = [&](int left) {
            if (left == s.size()) {
                res.push_back(current);
                return;
            }

            for (int right = left; right < s.size(); ++right) {
                if (isPalindrome(s, left, right)) {
                    current.push_back(s.substr(left, right - left + 1));  // 当前回文子串加入当前路径
                    dfs(right + 1);  // 递归寻找剩下的部分
                    current.pop_back();  // 回溯，移除当前子串
                }
            }
        };
        
        dfs(0);  // 从索引 0 开始进行回溯
        return res;
    }
};

```

## 9.N皇后

```c++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> res;  // 存储最终的解
        vector<string> board(n, string(n, '.'));  // 初始化棋盘
        vector<bool> cols(n, false);  // 用于标记列是否被占用
        vector<bool> diag1(2 * n - 1, false);  // 用于标记 "/" 方向的对角线是否被占用
        vector<bool> diag2(2 * n - 1, false);  // 用于标记 "\" 方向的对角线是否被占用
        backtrack(res, board, 0, n, cols, diag1, diag2);  // 开始回溯
        return res;
    }

private:
    // 回溯函数
    void backtrack(vector<vector<string>>& res, vector<string>& board, int row, int n, 
                   vector<bool>& cols, vector<bool>& diag1, vector<bool>& diag2) {
        if (row == n) {  // 所有行都已放置皇后
            res.push_back(board);
            return;
        }
        
        for (int col = 0; col < n; ++col) {
            // 检查当前列和对角线是否已被占用
            if (cols[col] || diag1[row + col] || diag2[row - col + n - 1]) 
                continue;
            
            // 放置皇后
            board[row][col] = 'Q';
            cols[col] = true;
            diag1[row + col] = true;
            diag2[row - col + n - 1] = true;
            
            // 递归放置下一行的皇后
            backtrack(res, board, row + 1, n, cols, diag1, diag2);
            
            // 回溯
            board[row][col] = '.';  // 恢复棋盘
            cols[col] = false;
            diag1[row + col] = false;
            diag2[row - col + n - 1] = false;
        }
    }
};

```

## 10.解数独

```c++
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtrack(board);
    }

private:
    // 回溯法：尝试填充每个空格
    bool backtrack(vector<vector<char>>& board) {
        for (int row = 0; row < 9; ++row) {
            for (int col = 0; col < 9; ++col) {
                if (board[row][col] == '.') {  // 如果当前格子是空的
                    for (char num = '1'; num <= '9'; ++num) {  // 尝试每个数字
                        if (isValid(board, row, col, num)) {  // 检查是否合法
                            board[row][col] = num;  // 填充当前数字
                            if (backtrack(board)) {  // 继续递归填充下一个空格
                                return true;  // 找到一个解
                            }
                            board[row][col] = '.';  // 回溯，撤销当前填充
                        }
                    }
                    return false;  // 如果没有找到合法数字，回溯
                }
            }
        }
        return true;  // 所有格子都已填充完成，返回 true
    }

    // 检查填充的数字是否在当前行、列和 3x3 宫格中合法
    bool isValid(vector<vector<char>>& board, int row, int col, char num) {
        for (int i = 0; i < 9; ++i) {
            // 检查行和列
            if (board[row][i] == num || board[i][col] == num) {
                return false;
            }
            // 检查 3x3 宫格
            //一个/  一个%
            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) {
                return false;
            }
        }
        return true;
    }
};

```

```c++
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        function<bool()> dfs = [&]()->bool{
            for(int i = 0;i < 9;i++){
                for(int j = 0;j < 9;j++){
                    if(board[i][j] != '.') continue;
                    for(char num = '1';num <= '9';num++){
                        if(isValid(board,i,j,num)){
                            board[i][j] = num;
                            if(dfs()) return true;
                        }
                        
                    }
                    board[i][j] = '.';
                    return false;
                }
            }
            return true;
        };
        dfs();
    }
    bool isValid(vector<vector<char>>& board,int row,int col,char num){
        for(int i = 0;i < 9;i++){
            if(board[row][i] == num || board[i][col] == num || 
                                    board[i / 3 + row / 3 * 3][i % 3 +  col / 3 * 3] == num)
                return false;
        }
        return true;
    }
};
```

## 11.复原IP地址(回溯)

### 1.递归时变化的量通常直接作为递归函数的参数，这样方便回溯

### 2.递归函数最终处理一般是最后一个处理的下一段

```c++
class Solution {
private:
    vector<string> ans;
public:
    void dfs(string& s, int m, int n, string cur) {
        if (n == 4) { // 处理第四段   //对应2
            if (m == s.size()) { // 必须用完所有字符
                ans.push_back(cur);
            }
            return;
        }
        
        for (int i = 1; i <= 3; ++i) { // 取 1~3 位数字
            if (m + i > s.size()) return; // 越界检查
            string segment = s.substr(m, i);
            int num = stoi(segment);
            
            if (num > 255) return; // 不能超过 255
            if (segment.size() > 1 && segment[0] == '0') return; // 不能有前导 0
			//对应1
            dfs(s, m + i, n + 1, cur + segment + (n == 3 ? "" : ".")); // 递归
        }
    }

    vector<string> restoreIpAddresses(string s) {
        if (s.size() < 4 || s.size() > 12) return ans; // 长度超出范围
        dfs(s, 0, 0, "");
        return ans;
    }
};

```

### 我开始的写法，没把变化的量作为递归函数参数，回溯很麻烦还容易错

```c++
class Solution {
private:
    vector<string> ans;
    string cur;
public:
//m代表遍历到s的第几位
//n代表ip的第几个数
    void dfs(string& s,int m,int n,string& cur){
        int sum = 0;
        if(n == 4){
            string temp = cur;
            if(s.size() == m) return;
            if(s.size() - m  > 3) return;
            if(m != s.size() - 1 && s[m] == '0'){
                return;
            }
            for(int i = m;i < s.size();i++){
                temp.push_back(s[i]);
                sum = s[i] - '0' + sum * 10;
            }
            if(sum >=0 && sum <= 255){
                ans.push_back(temp);
                return;
            }
            return;
        }
        if(s[m] == '0') {
            cur.push_back('0');
            cur.push_back('.');
            dfs(s,m+1,n+1,cur);
            cur.erase(cur.size() - 2);
            return;
            }
        else {
            int flag = 0;
            for(int i = m;i < m + 3 && i < s.size();i++){
                flag++;
                sum = s[i] - '0' + sum * 10;
                if(sum >=0 && sum <= 255) {
                    cur.push_back(s[i]);
                    cur.push_back('.');
                    dfs(s,i + 1,n + 1,cur);
                    cur.erase(cur.size() - 1);
                }
                else {
                    cur.erase(cur.size() - i + m );
                    return;
                }
            }
            cur.erase(cur.size() - flag);
        }
        
        return;
    }
    vector<string> restoreIpAddresses(string s) {
        dfs(s,0,1,cur);
        return ans;
    }
};
```



# 二十一、大数问题

## 1.字符串相加

## 2.大数相减

# 二十二、动态规划(画树)(基础)(01背包)(完全背包)(爬楼梯)(选还是不选)(多重背包)(分组背包)

**背包问题(至多 恰好 至少)    背包问题就用一维数组来做！**

**动态规划的时间复杂度 = 状态个数 × 单个状态的计算时间**

# [背包问题详解](https://blog.csdn.net/2301_79558858/article/details/137546255)

# **01背包 先遍历所有物品 再  ‘’‘逆序’‘’  遍历背包容量**

**完全背包问题中，你的遍历顺序是不同的。完全背包问题允许每个物品被多次选择，因此，你需要 先遍历背包容量，然后再遍历物品。这和 0-1 背包问题的遍历顺序是相反的。**



**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组





**动态规划注意事项：①一维数组初始值对不对**

**②两个for循环有没有反**

**③需不需要max min**

**④递归是从最后往前算  而动态规划是从开始往最后算**

**注：动态规划有「选或不选」和「枚举选哪个」这两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考。**



在完全背包、0-1 背包、以及多重背包和分组背包问题中，遍历顺序有所不同。具体来说：

1. **完全背包问题**

在完全背包问题中，背包的容量是可以多次装入同一个物品的。因此，遍历顺序是 **先遍历背包容量，再遍历物品**。这种遍历顺序保证了每个物品能够被多次使用。

2. **0-1 背包问题**

在 0-1 背包问题中，每个物品只能使用一次，因此遍历顺序是 **先遍历物品，再遍历背包容量**。这样做可以确保物品的每次选择只影响当前背包容量的计算，而不干扰之前的物品选择。

3. **多重背包问题**

在多重背包问题中，每个物品的使用次数是有限制的，因此，需要通过动态规划的方法来处理。通常，遍历顺序是 **先遍历物品，再遍历背包容量**，但是在更新 dp 数组时要根据物品的数量来处理选择次数。

常见的做法是通过将一个物品分成多个“虚拟”物品进行处理，或采用二进制拆分方法来避免重复计算。遍历顺序和 0-1 背包类似，但需要在选择物品时考虑物品的数量限制。

4. **分组背包问题**

在分组背包问题中，物品被分为若干组，在每组内可以选择任意物品，但每组只能选择一个物品。通常，遍历顺序是 **先遍历背包容量，再遍历每组物品**。这种遍历方式确保了在背包容量已经确定的情况下，选择每个组内的物品时不受干扰。

总结：

- **完全背包**：先遍历背包容量，再遍历物品。
- **0-1 背包**：先遍历物品，再遍历背包容量。
- **多重背包**：先遍历物品，再遍历背包容量，但考虑物品数量限制。
- **分组背包**：先遍历背包容量，再遍历每组物品。

## 爬楼梯 01背包 完全背包 多维dp 灵活dp 五种题型

## 1.爬楼梯

### 首先想到常规递归

```c++
// 会超时的递归代码
class Solution {
    int dfs(int i) {
        if (i <= 1) { // 递归边界
            return 1;
        }
        return dfs(i - 1) + dfs(i - 2);
    }

public:
    int climbStairs(int n) {
        return dfs(n);
    }
};

```

### 递归 + 记录返回值 = 记忆化搜索

```c++
class Solution {
    vector<int> memo;

    int dfs(int i) {
        if (i <= 1) { // 递归边界
            return 1;
        }
        int& res = memo[i]; // 注意这里是引用
        if (res) { // 之前计算过
            return res;
        }
        return res = dfs(i - 1) + dfs(i - 2); // 记忆化
    }

public:
    int climbStairs(int n) {
        memo.resize(n + 1);
        return dfs(n);
    }
};
```

### 递推

```c++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> f(n + 1);
        f[0] = f[1] = 1;
        for (int i = 2; i <= n; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }
};
```

### 空间优化

```c++
class Solution {
public:
    int climbStairs(int n) {
        int f0 = 1, f1 = 1;
        for (int i = 2; i <= n; i++) {
            int new_f = f1 + f0;
            f0 = f1;
            f1 = new_f;
        }
        return f1;
    }
};
```

## 2.打家劫舍

```cpp
class Solution {
public:
    int dfs(vector<int>& nums, int num){
        if(num > nums.size() - 1) return 0;
        if(num == nums.size() - 1) return nums[num];
        if(num == nums.size() - 2) return max(nums[num],nums[num + 1]);
        int temp = 0;
        //选第一个
        temp += nums[num];
        int first = dfs(nums,num + 2) + temp;
        //恢复
        temp = 0;
        //选第二个
        temp += nums[num+1];
        int second = dfs(nums,num + 3) + temp;
        return max(first,second);
    }
    int rob(vector<int>& nums) {
        int res = dfs(nums,0);
        return res;
    }
};
```

存在以下几个问题和优化点：

### 问题分析：

1. **重复子问题导致性能低下：**
   - `dfs` 函数在同一个 `num` 上会被多次调用，导致大量的重复计算。例如：在计算 `dfs(nums, 2)` 时，它可能会多次计算相同的子问题。
   - 这是典型的 **重叠子问题**，可以使用动态规划或记忆化搜索来优化。
2. **不必要的变量 `temp`：**
   - 变量 `temp` 用于保存 `nums[num]` 或 `nums[num + 1]`，但实际上并不需要，它可以直接用 `nums[num]` 和 `nums[num + 1]` 替代。
3. **没有对输入进行边界检查：**
   - 当 `nums` 的长度为 0 或 1 时，代码虽然能处理，但未显式说明行为。

------

### 优化思路：

1. **记忆化搜索（Memoization）：**
   - 使用一个数组 `memo` 来保存 `dfs(nums, num)` 的结果。如果某个位置的值已经计算过，则直接返回，避免重复计算。
2. **去掉冗余变量：**
   - 直接使用递归结果，避免中间变量。
3. **动态规划（非递归）：**
   - 可进一步优化为自底向上的动态规划，空间复杂度从 O(n)O(n) 降到 O(1)O(1)。

------

### 修复后的代码：

使用记忆化搜索优化递归版本：

```cpp
class Solution {
public:
    int dfs(vector<int>& nums, int num, vector<int>& memo) {
        if (num >= nums.size()) return 0;  // 超出数组范围返回 0
        if (memo[num] != -1) return memo[num];  // 返回已计算的结果

        // 选当前房子或不选当前房子的最大值
        int res = max(nums[num] + dfs(nums, num + 2, memo), dfs(nums, num + 1, memo));
        memo[num] = res;  // 保存结果
        return res;
    }

    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;  // 边界情况
        vector<int> memo(nums.size(), -1);  // 初始化记忆化数组
        return dfs(nums, 0, memo);  // 从第 0 个房子开始
    }
};
```

------

### 动态规划优化：

动态规划的核心是将递归转换为迭代，避免函数调用栈的开销。

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;  // 边界情况
        if (nums.size() == 1) return nums[0];  // 只有一个房子

        int prev2 = 0, prev1 = 0;  // `prev2` 表示两步之前，`prev1` 表示一步之前的最大值
        for (int num : nums) {
            int curr = max(prev1, prev2 + num);  // 当前房子的选择
            prev2 = prev1;  // 更新两步之前的值
            prev1 = curr;  // 更新一步之前的值
        }
        return prev1;  // 返回最终结果
    }
};
```

------

### 优化后的复杂度：

1. 时间复杂度：
   - 记忆化搜索和动态规划都是 O(n)O(n)，其中 nn 是房子的数量。
2. 空间复杂度：
   - 记忆化搜索为 O(n)O(n)（递归栈和 `memo` 数组）。
   - 动态规划优化版本为 O(1)O(1)。

------

### 示例：

#### 输入：

```cpp
vector<int> nums = {2, 7, 9, 3, 1};
```

#### 输出：

最大金额为 12。

解释：

- 选择第 1、3、5 个房子（金额为 2、9、1）。
- 总金额为 2+9+1=122 + 9 + 1 = 12。

## **3.目标和

### 暴力回溯(超时)

#### 错误代码

```c++
class Solution { 
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int res = 0;
        int ans = 0;
        function<void(int)> dfs = [&](int n){
            if(n == -1){
                if(res == target) ans++;
                return;
            }
            res -= nums[n];
            dfs(n - 1);
            res = res + 2*nums[n];
            dfs(n - 1);
        };
        dfs(nums.size() - 1);
        return ans;
    }
};
```

**回溯时要把中间变化的量作为局部变量传递**

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int ans = 0;
        function<void(int,int)> dfs = [&](int n,int sum){
            if(n == -1){
                if(sum == target) ans++;
                return;
            }
            
            dfs(n - 1,sum - nums[n]);
            dfs(n - 1,sum + nums[n]);
        };
        dfs(nums.size() - 1,0);
        return ans;
    }
};
```

**暴力回溯时尽量使用函数，使用lambda捕获参数会更加耗时，下面代码能通过**

```c++
class Solution {
public:
    int ans = 0;
    void dfs(int n,int res,int& target,vector<int>& nums){
        if(n == nums.size()) {
                if(res == target) ans++;
                return ;
            }
            dfs(n + 1,res + nums[n],target,nums);
            dfs(n + 1,res - nums[n],target,nums);
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        dfs(0,0,target,nums);
        return ans;
    }
};
```



### DP(01背包问题)

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        if((target + sum) % 2 != 0 || (target + sum) < 0) return 0;
        vector<int> memo((target + sum) / 2 + 1,0);
        memo[0] = 1;
        for(int num : nums){
            for(int i = (target + sum) / 2;i >=0;i--){
                if((i - num) >= 0)
                    memo[i] += memo[i - num];
            }
        }
        return memo[(target + sum) / 2];
    }
};
```



## 4.零钱兑换

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> memo(amount + 1,-1);
        memo[0] = 0;
        for(int i = 1;i <= amount;i++){
            for(int co : coins){
                if(co <= i && memo[i - co] != -1){
                    if(memo[i] != -1)
                        memo[i] = min(memo[i - co] + 1,memo[i]);
                    else
                        memo[i] = memo[i - co] + 1;
                }
            }
        }
        return memo[amount];
    }
};
```



## 5.完全平方数

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> memo(n + 1,-1);
        function<int(int)> dfs = [&](int n)->int{
            if(n == 1) return 1;
            if(memo[n] != -1) return memo[n]; 
            int res = n;
            for(int i = 1;i*i <= n;i++){
                res = min(dfs(n - i*i) + 1,res);
            }
            memo[n] = res;
            return res;
        };
        return dfs(n);
    }
};
```

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> memo(n + 1,n);
        memo[0] = 0;		//从0开始初始化
        for(int i = 1;i <= n;i++){
            for(int j = 1;j*j <= i;j++){
                memo[i] = min(memo[i],memo[i-j*j] + 1) ;
            }
        }
        return memo[n];
    }
};
```



## 6.组合总数IV

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> memo(target + 1, -1); // -1 表示没有计算过//这里是-1
        auto dfs = [&](this auto&& dfs, int i) {
            if (i == 0) { // 爬完了
                return 1;
            }
            int &res = memo[i]; // 注意这里是引用
            if (res != -1) { // 之前计算过
                return res;
            }
            res = 0;
            for (int x : nums) {
                if (x <= i) {
                    res += dfs(i - x);
                }
            }
            return res;
        };
        return dfs(target);
    }
};
```

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        // 使用 unsigned 可以让溢出不报错
        // 对于溢出的数据，不会影响答案的正确性（题目保证）
        vector<unsigned> f(target + 1，0);//这里是0
        f[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int x : nums) {
                if (x <= i) {
                    f[i] += f[i - x];
                }
            }
        }
        return f[target];
    }
};
```

## 7.单词划分

### 主要注意substr函数的使用

```c++
class Solution {
    public:
        int wordBreak(string s, vector<string>& wordDict) {
            vector<bool> memo(s.size() + 1, 0);
            memo[0] = 1;  // 初始化，表示空字符串总是能被分词
    
            for (int i = 1; i <= s.size(); i++) {
                for (string ch : wordDict) {
                    // 如果当前索引 i 能匹配到字典中的单词，并且 memo[i - ch.size()] 是可行的
                    if (i >= ch.size() && s.substr(i - ch.size(), ch.size()) == ch) {
                        memo[i] = memo[i] | memo[i - ch.size()];
                    }
                }
            }
    
            return memo[s.size()];
        }
    };
    
```

## 8.最小路径和(网格dp)(优化空间？)

## 9.下降路径最小和(网格dp)(优化空间？)

```c++
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int row = matrix.size();
        int col = matrix[0].size();
        vector<vector<int>> memo(row + 1,vector<int>(col,INT_MAX));
        for(int i = 0;i < col;i++){
            memo[0][i] = 0;
        }
        for(int i = 1;i <= row;i++){
            for(int j = 0;j < col;j++){
                memo[i][j] = min(min((j - 1 >= 0 ? memo[i - 1][j - 1] : INT_MAX),
                             (j + 1 < col ? memo[i - 1][j + 1] : INT_MAX)), 
                             (memo[i - 1][j])) + matrix[i - 1][j];
            }
        }
        return *min_element(memo[row].begin(),memo[row].end());
    }
};
```



## 10.最长公共子序列(线性dp 多维)

## ***11.编辑距离(线性dp 多维)

[类似字符串增删操作总结](https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97)

### [#](https://programmercarl.com/0072.编辑距离.html#_1-确定dp数组-dp-table-以及下标的含义)1. 确定dp数组（dp table）以及下标的含义

**dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。

有同学问了，为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？

为什么这么定义我在 [718. 最长重复子数组 (opens new window)](https://programmercarl.com/0718.最长重复子数组.html)中做了详细的讲解。

其实用i来表示也可以！ 用i-1就是为了方便后面dp数组初始化的。

### [#](https://programmercarl.com/0072.编辑距离.html#_2-确定递推公式)2. 确定递推公式

在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：

```text
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```

也就是如上4种情况。

```
if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1];
```

此时可能有同学有点不明白，为啥要即`dp[i][j] = dp[i - 1][j - 1]`呢？

那么就在回顾上面讲过的`dp[i][j]`的定义，`word1[i - 1]` 与 `word2[j - 1]`相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串`word2`的最近编辑距离`dp[i - 1][j - 1]`就是 `dp[i][j]`了。

在下面的讲解中，如果哪里看不懂，就回想一下`dp[i][j]`的定义，就明白了。

**在整个动规的过程中，最为关键就是正确理解`dp[i][j]`的定义！**

`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？

- 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。

即 `dp[i][j] = dp[i - 1][j] + 1;`

- 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。

即 `dp[i][j] = dp[i][j - 1] + 1;`

这里有同学发现了，怎么都是删除元素，添加元素去哪了。

**word2添加一个元素，相当于word1删除一个元素**，例如 `word1 = "ad" ，word2 = "a"`，`word1`删除元素`'d'` 和 `word2`添加一个元素`'d'`，变成`word1="a", word2="ad"`， 最终的操作数是一样！ dp数组如下图所示意的：

```text
            a                         a     d
   +-----+-----+             +-----+-----+-----+
   |  0  |  1  |             |  0  |  1  |  2  |
   +-----+-----+   ===>      +-----+-----+-----+
 a |  1  |  0  |           a |  1  |  0  |  1  |
   +-----+-----+             +-----+-----+-----+
 d |  2  |  1  |
   +-----+-----+
```

操作三：替换元素，`word1`替换`word1[i - 1]`，使其与`word2[j - 1]`相同，此时不用增删加元素。

可以回顾一下，`if (word1[i - 1] == word2[j - 1])`的时候我们的操作 是 `dp[i][j] = dp[i - 1][j - 1]` 对吧。

那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。

所以 `dp[i][j] = dp[i - 1][j - 1] + 1;`

综上，当 `if (word1[i - 1] != word2[j - 1])` 时取最小的，即：`dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;`

递归公式代码如下：

```cpp
if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1];
}
else {
    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
}
```

------

### [#](https://programmercarl.com/0072.编辑距离.html#_3-dp数组如何初始化)3. dp数组如何初始化

再回顾一下dp[i][j]的定义：

**dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。

那么dp[i][0] 和 dp[0][j] 表示什么呢？

dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。

那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i;

同理dp[0][j] = j;

所以C++代码如下：

```cpp
for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
```

### [#](https://programmercarl.com/0072.编辑距离.html#_4-确定遍历顺序)4. 确定遍历顺序

从如下四个递推公式：

- `dp[i][j] = dp[i - 1][j - 1]`
- `dp[i][j] = dp[i - 1][j - 1] + 1`
- `dp[i][j] = dp[i][j - 1] + 1`
- `dp[i][j] = dp[i - 1][j] + 1`

可以看出dp[i][j]是依赖左方，上方和左上方元素的，如图：

![72.编辑距离](https://code-thinking-1253855093.file.myqcloud.com/pics/20210114162113131.jpg)

所以在dp矩阵中一定是从左到右从上到下去遍历。

代码如下：

```cpp
for (int i = 1; i <= word1.size(); i++) {
    for (int j = 1; j <= word2.size(); j++) {
        if (word1[i - 1] == word2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1];
        }
        else {
            dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
        }
    }
}
```

### [#](https://programmercarl.com/0072.编辑距离.html#_5-举例推导dp数组)5. 举例推导dp数组

以示例1为例，输入：`word1 = "horse", word2 = "ros"`为例，dp矩阵状态图如下：

![72.编辑距离1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210114162132300.jpg)

以上动规五部分析完毕，C++代码如下：

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else {
                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

- 时间复杂度: O(n * m)
- 空间复杂度: O(n * m)

## 12.最长递增子序列

### 动态规划

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> memo(nums.size(),1);
        int res = 0;
        for(int i = 0;i < nums.size();i++){
            for(int j = 0;j < i;j++){
                if(nums[i] > nums[j]){
                    memo[i] = max(memo[i],memo[j] + 1);
                }
            }
            res = max(res,memo[i]);
        }
        return res;
    }
};
```



### 贪心+二分

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> memo;
        memo.push_back(nums[0]);
        for (int i = 1; i < nums.size(); i++) {
            int left = 0;
            int right = memo.size() - 1;
            int mid = 0;
            if (nums[i] > memo[memo.size() - 1]) {
                memo.push_back(nums[i]);
            } else {
                while (left <= right) {
                    mid = (left + right) / 2;
                    if (nums[i] <= memo[mid]) {
                        right = mid - 1;
                    } else {
                        left = mid + 1;
                    }
                }
                
                memo[left] = nums[i];
            }
        }
        return memo.size();
    }
};
```



## ***13.将三个组排序

### 状态机dp

### 贪心+二分

```c++
class Solution {
public:
    int minimumOperations(vector<int>& nums) {
        vector<int> memo;
        memo.push_back(nums[0]);
        for(int i = 1;i < nums.size();i++){
            int left = 0;
            int right = memo.size() - 1;
            if(nums[i] >= memo[memo.size() - 1]){
                memo.push_back(nums[i]);
            } else {
                while(left <= right){
                    int mid = (left + right) / 2;
                    if(memo[mid] <= nums[i]){
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
                memo[left] = nums[i];
                
            }
        }
        return nums.size() - memo.size();
    }
};
```

## 注意二分查找的区别

`upper_bound` 和 `lower_bound` 的主要区别在于：

- `lower_bound(nums, target)`: 返回 **第一个** `>= target` 的元素索引（即**大于等于 target** 的最左侧位置）。
- `upper_bound(nums, target)`: 返回 **第一个** `> target` 的元素索引（即**严格大于 target** 的最左侧位置）。

```c++
 int lower_bound(vector<int>& nums, int target) {
        int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
        while (left <= right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right+1] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1; // 范围缩小到 [mid+1, right]
            } else {
                right = mid - 1; // 范围缩小到 [left, mid-1]
            }
        }
        return left;
    }

int upper_bound(vector<int>& nums, int target) {
    int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
    while (left <= right) { // 区间不为空
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) { // 注意这里是 <=
            left = mid + 1; // 继续查找右侧 [mid+1, right]
        } else {
            right = mid - 1; // 继续查找左侧 [left, mid-1]
        }
    }
    return left;
}

```

## 14.股票问题(状态机dp)(画出状态转换图)

## 买卖股票的最佳时机(买一次)

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int start = prices[0];
        int profit = 0;
        for(int i = 0;i < prices.size();i++){
            if(prices[i] < start) start = prices[i];
            else profit = max(prices[i] - start,profit);
        }
        return profit;
    }
};
```



## 买卖股票的最佳时机II(买多次)

这里重申一下dp数组的含义：

- dp[i][0] 表示第i天持有股票所得现金。
- dp[i][1] 表示第i天不持有股票所得最多现金

如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]
- 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1] [1] - prices[i]

而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。

那么第i天持有股票即dp[i][0]，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：dp[i - 1] [1] - prices[i]。

再来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]
- 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1] [0]

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(),vector<int>(2,0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1;i < prices.size();i++){
            dp[i][0] = max(dp[i - 1][0],dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1],dp[i - 1][0] + prices[i]);
        }
        return dp[prices.size() - 1][1];
    }
};
```

**空间优化**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int a = -prices[0];
        int b = 0;
        int temp;
        for(int i = 1;i < prices.size();i++){
            temp = a;
            a = max(a,b - prices[i]);
            b = max(b,temp + prices[i]);
        }
        return b;
    }
};
```



## 买卖股票的最佳时机III(买两次)

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int buy1 = -prices[0], sell1 = 0;
        int buy2 = -prices[0], sell2 = 0;
        for (int i = 1; i < n; ++i) {
            buy1 = max(buy1, -prices[i]);
            sell1 = max(sell1, buy1 + prices[i]);
            buy2 = max(buy2, sell1 - prices[i]);
            sell2 = max(sell2, buy2 + prices[i]);
        }
        return sell2;
    }
};
```



## 买卖股票的最佳时机IV(买k次)

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {

        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1;i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

## 买卖股票的最佳时机含冷冻期

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(),vector<int>(2,0));
        dp[0][0] = -prices[0];
        for(int i = 1;i < prices.size();i++){
            if(i - 2 >=0)
                dp[i][0] = max(dp[i - 1][0],dp[i - 2][1] - prices[i]);
            else 
                dp[i][0] = max(dp[i - 1][0],-prices[i]);
            dp[i][1] = max(dp[i - 1][1],dp[i - 1][0] + prices[i]);
        }
        return dp[prices.size() - 1][1];
    }
};
```

## 买卖股票的最佳时机含手续费

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<vector<int>> dp(prices.size(),vector<int>(2,0));
        dp[0][0] = -prices[0];
        for(int i = 1;i < prices.size();i++){
            dp[i][0] = max(dp[i - 1][0],dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1],dp[i - 1][0] + prices[i] - fee);
        }
        return dp[prices.size() - 1][1];
    }
};
```

## 15.最长回文子序列

### 回文问题：定义dp[i] [j] 为i到j范围内最长回文序列

### 分i==j 和 i != j

### 这一题深刻提醒了一定要按照dp五部来一步一步做

1. **确定dp数组（dp table）以及下标的含义**
2. **确定递推公式**
3. **dp数组如何初始化**
4. **确定遍历顺序(这里的顺序很重要)**
5. **举例推导dp数组**

### 遍历顺序不一样

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(s.size(),0));
        for(int i = s.size() - 1;i >= 0;i--){
            for(int j = i;j < s.size();j++){
                if(s[i] == s[j]){
                    if(j - i <= 1) dp[i][j] = j - i + 1;
                    else dp[i][j] = dp[i + 1][j - 1] + 2;
                }
                else {
                    if(j - i <= 1) dp[i][j] = 1;
                    else dp[i][j] = max(dp[i + 1][j],dp[i][j - 1]);
                }
            }
        }
        return dp[0][s.size() - 1];
    }
};
```



## 16.回文子串

### dp不是最优解

## 17.打家劫舍II

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int firstHouse = 0;
        int secondHouse = 0;
        //不选0号
        for(int i = 1;i < nums.size();i++){
            firstHouse = max(secondHouse,firstHouse + nums[i]);
            swap(firstHouse,secondHouse);
        }
        int firstHouse2 = 0;
        int secondHouse2 = 0;
        //选0号
        for(int i = 2;i < nums.size() - 1;i++){
            firstHouse2 = max(secondHouse2,firstHouse2 + nums[i]);
            swap(firstHouse2,secondHouse2);
        }
        return max(secondHouse,secondHouse2 + nums[0]);
    }
};
```

## 18.打家劫舍III(选或不选之间状态选择)

![image-20250224112557567](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20250224112557567.png)

```c++
学习auto与pair这种写法
class Solution {
    pair<int, int> dfs(TreeNode* node) {
        if (node == nullptr) { // 递归边界
            return {0, 0}; // 没有节点，怎么选都是 0
        }
        auto [l_rob, l_not_rob] = dfs(node->left); // 递归左子树
        auto [r_rob, r_not_rob] = dfs(node->right); // 递归右子树
        int rob = l_not_rob + r_not_rob + node->val; // 选
        int not_rob = max(l_rob, l_not_rob) + max(r_rob, r_not_rob); // 不选
        return {rob, not_rob};
    }

public:
    int rob(TreeNode* root) {
        auto [root_rob, root_not_rob] = dfs(root);
        return max(root_rob, root_not_rob); // 根节点选或不选的最大值
    }
};
```

## 19.分割等和子集(01背包的恰好)

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        if(sum % 2 != 0) return false;
        sum = sum / 2;
        vector<int> dp(sum + 1,0);
        dp[0] = true;
        for(int i = 0;i < nums.size();i++){
            for(int j = sum ;j >= 0;j--){
                if(j - nums[i] >=0){
                    dp[j] |= dp[j - nums[i]];
                }
            }
        }
        return dp[sum];
    }
};
```

## 20.乘积最大子数组

### 注意负负得正

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        vector<int> dp(nums.size(),INT_MIN);
        vector<int> dp2(nums.size(),INT_MAX);
        dp[0] = nums[0];
        dp2[0] = nums[0];
        for(int i = 1;i < nums.size();i++){
            if(nums[i] >=0)
                dp[i] = max(nums[i],dp[i - 1] * nums[i]);
            else 
                dp[i] = max(nums[i],dp2[i - 1] * nums[i]);
            dp2[i] = min(min(nums[i],dp2[i - 1] * nums[i]),dp[i - 1] * nums[i]);
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```



# 二十三、优先队列(堆)

## 1.使用服务器处理任务

# 二十四、字符串问题(kmp)(manacher)(还没看)

## 1.最长回文子串

### dp

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool>> dp(s.size(),vector<bool>(s.size(),false));
        for(int i = 0;i < s.size();i++){
            dp[i][i] = true;
        }
        for(int i = s.size() - 1;i >= 0;i--){
            for(int j = i + 1;j < s.size();j++){
                if(s[i] == s[j]){
                    if(j - i <= 1) dp[i][j] = true;
                    else dp[i][j] = dp[i + 1][j - 1];
                }
                else dp[i][j] = false;
            }
        }
        int ans = 0;
        string res;
        for(int i = 0;i < s.size();i++){
            for(int j = s.size() - 1;j >=0;j--){
                if(dp[i][j] == true) {
                    if(j - i >= ans){
                        ans = j - i;
                        res= s.substr(i,j - i + 1);
                    }
                }
            }
        }
        return res;
    }
};
```

### 中心扩散

### manacher

## 2.回文子串

### manacher

## 3.压缩字符串III(见前面双指针)

## 4.找出字符串中第一个匹配项的下标(模版kmp 背下来)

## (kmp就是不用find函数的查找算法)

**背过这样的算法的意义在于：相当于大脑里有了一个时间复杂度为O\(n\)的 api 可以使用，这个 api 传入一个原串和匹配串，返回匹配串在原串的位置**

时间复杂度：O(n+m)，其中n是字符串haystack的长度，m是字符串needle的长度。我们至多需要遍历两字符串一次。

空间复杂度：O(m)，其中m是字符串needle的长度。我们只需要保存字符串needle的前缀函数。

```c++
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        vector<int> next(needle.size());
        getNext(&next[0], needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```



## 5.旋转字符串(kmp)

## 6.比较版本号

### 字符串和数字之间的转换第一时间想到 + - '0'

```c++
class Solution {
public:
    int compareVersion(string version1, string version2) {
        int n = version1.length(), m = version2.length();
        int i = 0, j = 0;
        while (i < n || j < m) {
            long long x = 0;
            for (; i < n && version1[i] != '.'; ++i) {
                x = x * 10 + version1[i] - '0';
            }
            ++i; // 跳过点号
            long long y = 0;
            for (; j < m && version2[j] != '.'; ++j) {
                y = y * 10 + version2[j] - '0';
            }
            ++j; // 跳过点号
            if (x != y) {
                return x > y ? 1 : -1;
            }
        }
        return 0;
    }
};
```



## 7.复原IP地址(回溯)

### 1.递归时变化的量通常直接作为递归函数的参数，这样方便回溯

### 2.递归函数最终处理一般是最后一个处理的下一段

```c++
class Solution {
private:
    vector<string> ans;
public:
    void dfs(string& s, int m, int n, string cur) {
        if (n == 4) { // 处理第四段   //对应2
            if (m == s.size()) { // 必须用完所有字符
                ans.push_back(cur);
            }
            return;
        }
        
        for (int i = 1; i <= 3; ++i) { // 取 1~3 位数字
            if (m + i > s.size()) return; // 越界检查
            string segment = s.substr(m, i);
            int num = stoi(segment);
            
            if (num > 255) return; // 不能超过 255
            if (segment.size() > 1 && segment[0] == '0') return; // 不能有前导 0
			//对应1
            dfs(s, m + i, n + 1, cur + segment + (n == 3 ? "" : ".")); // 递归
        }
    }

    vector<string> restoreIpAddresses(string s) {
        if (s.size() < 4 || s.size() > 12) return ans; // 长度超出范围
        dfs(s, 0, 0, "");
        return ans;
    }
};

```

### 我开始的写法，没把变化的量作为递归函数参数，回溯很麻烦还容易错

```c++
class Solution {
private:
    vector<string> ans;
    string cur;
public:
//m代表遍历到s的第几位
//n代表ip的第几个数
    void dfs(string& s,int m,int n,string& cur){
        int sum = 0;
        if(n == 4){
            string temp = cur;
            if(s.size() == m) return;
            if(s.size() - m  > 3) return;
            if(m != s.size() - 1 && s[m] == '0'){
                return;
            }
            for(int i = m;i < s.size();i++){
                temp.push_back(s[i]);
                sum = s[i] - '0' + sum * 10;
            }
            if(sum >=0 && sum <= 255){
                ans.push_back(temp);
                return;
            }
            return;
        }
        if(s[m] == '0') {
            cur.push_back('0');
            cur.push_back('.');
            dfs(s,m+1,n+1,cur);
            cur.erase(cur.size() - 2);
            return;
            }
        else {
            int flag = 0;
            for(int i = m;i < m + 3 && i < s.size();i++){
                flag++;
                sum = s[i] - '0' + sum * 10;
                if(sum >=0 && sum <= 255) {
                    cur.push_back(s[i]);
                    cur.push_back('.');
                    dfs(s,i + 1,n + 1,cur);
                    cur.erase(cur.size() - 1);
                }
                else {
                    cur.erase(cur.size() - i + m );
                    return;
                }
            }
            cur.erase(cur.size() - flag);
        }
        
        return;
    }
    vector<string> restoreIpAddresses(string s) {
        dfs(s,0,1,cur);
        return ans;
    }
}
```

## 8.实现Trie

```c++
class Trie {
public:
    class Node{
    public:
        Node* son[26]{};
        bool end = false;
    };
    Node* root = nullptr;

    int find(string word){
        Node* cur = root;
        if(cur == nullptr) return 0;
        for(char c : word){
            c = c - 'a';
            if(cur->son[c] == nullptr){
                return 0;
            }
            cur = cur->son[c];
        }
        return cur->end == true ? 2 : 1;
    }

    Trie() {
        root = new Node();
    }
    
    void insert(string word) {
        Node* cur = root;
        for(char c : word){
            c = c - 'a';
            if(cur->son[c] == nullptr){
                cur->son[c] = new Node();
            }
            cur = cur->son[c];
        }
        cur->end = true;
    }
    
    bool search(string word) {
        return find(word) == 2;
    }
    
    bool startsWith(string prefix) {
        return find(prefix) >= 1;
    }
};
```



# 二十五、其他

## 1.整数反转

```c++
class Solution {
public:
    int reverse(int x) {
        int res = 0;
        while (x != 0) {
            int digit = x % 10;
            // 检查溢出情况
            if (res > INT_MAX / 10 || (res == INT_MAX / 10 && digit > 7)) {
                return 0;  // 溢出时返回 0
            }
            if (res < INT_MIN / 10 || (res == INT_MIN / 10 && digit < -8)) {
                return 0;  // 溢出时返回 0
            }
            res = res * 10 + digit;
            x /= 10;
        }
        return res;
    }
};

```



## 2.数组中两个数的最大异或值

## 3.随机数索引



# 二十六、技巧

## 1.只出现一次的数字(异或)

## 2.多数元素

```c++
class Solution {
public:
    //如果一个数组有大于一半的数相同，那么任意删去两个不同的数字，新数组还是会有相同的性质
    int majorityElement(vector<int>& nums) {
        int num = nums[0];
        //有一个数
        int count = 1;
        for(int i = 1;i < nums.size();i++){
            if(nums[i] == num){
                //相等不删
                count++;
            }
            //不等就把这两个数都删了
            //没有数了就加上一个数
            else if(--count < 0){
                num = nums[i];
                count = 1;
            }
        }
        return num;
    }
};
```



## 3.颜色分类

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        int ptr = 0;
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 0) {
                swap(nums[i], nums[ptr]);
                ++ptr;
            }
        }
        for (int i = ptr; i < n; ++i) {
            if (nums[i] == 1) {
                swap(nums[i], nums[ptr]);
                ++ptr;
            }
        }
    }
};
```

## 4.下一个排列

```c++
/*
以排列 [4,5,2,6,3,1] 为例：

我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。

当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。

具体地，我们这样描述该算法，对于长度为 n 的排列 a：

首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]<a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。

如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i]<a[j]。这样「较大数」即为 a[j]。

交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。
*/

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        while(i >=0 && nums[i] >= nums[i + 1]) i--;
        if(i >= 0){
            int j = nums.size() - 1;
            while(j>=0 && nums[i] >= nums[j]) j--;
            swap(nums[i],nums[j]);
        }
        reverse(nums.begin() + i + 1,nums.end());
    }
};
```

## 5.寻找重复数

```c++
/*
如果数组中有重复的数，以数组 [1,3,4,2,2] 为例,我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)，
其映射关系 n->f(n) 为：
0->1
1->3
2->4
3->2
4->2
同样的，我们从下标为 0 出发，根据 f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。
0->1->3->2->4->2->4->2->……
利用快慢指针
*/
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        
        int fast = 0, slow = 0;
        while(true){
            fast = nums[nums[fast]];
            slow = nums[slow];
            if(fast == slow)
                break;
        }
        int finder = 0;
        while(true){
            finder = nums[finder];
            slow = nums[slow];
            if(slow == finder)
                break;        
        }
        return slow;
    }
};
```



# N、妙数组

## 4.数字分组求偶数和

小M面对一组从 1 到 9 的数字，这些数字被分成多个小组，并从每个小组中选择一个数字组成一个新的数。目标是使得这个新数的各位数字之和为偶数。任务是计算出有多少种不同的分组和选择方法可以达到这一目标。

- `numbers`: 一个由多个整数字符串组成的列表，每个字符串可以视为一个数字组。小M需要从每个数字组中选择一个数字。

例如对于`[123, 456, 789]`，14个符合条件的数为：`147 149 158 167 169 248 257 259 268 347 349 358 367 369`。

```cpp
int solution(std::vector<int> numbers) {
    // Please write your code here
   int count_ou = 1;
   int count_ji = 0;

   int m = numbers.size();
   for(int i =0;i < m;i++){
    int temp = numbers[i];
    int group_ou = 0;
    int group_ji = 0;
       
    while(temp > 0){
        int tep = temp % 10;
        if(tep % 2 == 0){
            group_ou++;
        } else {
            group_ji++;
        }
        temp /= 10;
    }

    int ji = count_ou * group_ji + count_ji * group_ou;
    int ou = count_ou * group_ou + count_ji * group_ji;
    count_ji = ji;
    count_ou = ou;
   }
    return count_ou;
}
```

如果我们用 `n` 表示所有数字的位数的总和（即所有数字组中数字的总位数），那么时间复杂度可以简化为：

O(n)



## 5.寻找最大葫芦

在一场经典的德州扑克游戏中，有一种牌型叫做“葫芦”。“葫芦”由五张牌组成，其中包括三张相同牌面值的牌 𝑎*a* 和另外两张相同牌面值的牌 𝑏*b*。如果两个人同时拥有“葫芦”，我们会优先比较牌 𝑎*a* 的大小，若牌 𝑎*a* 相同则再比较牌 𝑏*b* 的大小，牌面值的大小规则为：1 (A) > K > Q > J > 10 > 9 > ... > 2，其中 1 (A) 的牌面值为1，K 为13，依此类推。

在这个问题中，我们对“葫芦”增加了一个限制：组成“葫芦”的五张牌牌面值之和不能超过给定的最大值 𝑚𝑎𝑥*ma**x*。

给定一组牌，你需要找到符合规则的最大的“葫芦”组合，并输出其中三张相同的牌面和两张相同的牌面。如果找不到符合条件的“葫芦”，则输出 “0, 0”。

------

**测试样例**

***样例1：***

> 输入：`n = 9, max = 34, array = [6, 6, 6, 8, 8, 8, 5, 5, 1]`
> 输出：`[8, 5]`
> 说明：`array`数组中可组成4个葫芦，分别为[6,6,6,8,8],[6,6,6,5,5],[8,8,8,6,6],[8,8,8,5,5]。其中[8,8,8,6,6]的牌面值为36，大于34不符合要求。剩下的3个葫芦的大小关系为[8,8,8,5,5]>[6,6,6,8,8]>[6,6,6,5,5],故返回[8,5]



**不难但麻烦，考验基本功**

```cpp
std::vector<int> solution(int n, int max, const std::vector<int>& array) {
    // Edit your code here
    std::unordered_map<int, int> count_map;
    for(auto a : array){
        count_map[a]++;
    }

    std::vector<int> sec = {};
    std::vector<int> third = {};

    for(auto a : count_map){
        if(a.second >=3) third.push_back(a.first);
        if(a.second >=2) sec.push_back(a.first);
    }

    sort(sec.rbegin(),sec.rend());
    sort(third.rbegin(),third.rend());
    int i =third.size();
    int j = sec.size();
    if(i == 0 || j == 0) return {0,0};
    if(sec[sec.size()-1] == 1) {
        sec.insert(sec.begin(),1);
        sec.erase(sec.end());
    }
    if(third[third.size()-1] == 1){
        third.insert(third.begin(),1);
        third.erase(third.end());
    }


    for(int m = 0; m < i;m++){
        for(int k = 0; k < j;k++){
            if(third[m] == sec[k]) continue;
            int sum = third[m] * 3 + sec[k] * 2;
            if(sum <= max) return {third[m],sec[k]};
        }
    }

    return {0, 0};
}
```

## 15.最少前缀操作



## 169.多数元素

哈希表统计法： 遍历数组 nums ，用 HashMap 统计各数字的数量，即可找出 众数 。此方法时间和空间复杂度均为 O(N) 。
数组排序法： 将数组 nums 排序，数组中点的元素 一定为众数。
摩尔投票法： 核心理念为 票数正负抵消 。此方法时间和空间复杂度分别为 O(N) 和 O(1) ，为本题的最佳解法。

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int x = 0, votes = 0;
        for (int num : nums){
            if (votes == 0) x = num;
            votes += num == x ? 1 : -1;
        }
        return x;
    }
};
```

## 124.有限制的楼梯攀登

# SQL题

## 1.使用**LIMIT**限制返回行数

这两段 SQL 查询语句解释如下：

### 1. **选取前n行**

#### 语法一：`SELECT 数据列 FROM 数据表 LIMIT 0, 5`

- **LIMIT** 是用于限制返回结果的条数。
- `0, 5` 表示从第 0 行开始（包括第 0 行），取 5 行数据。所以这是查询 **前 5 行** 的方式。

#### 语法二：`SELECT 数据列 FROM 数据表 LIMIT 5`

- 这个语法等价于上面第一个语法，默认从第 0 行开始（即 `LIMIT 5` 等价于 `LIMIT 0, 5`）。
- 结果同样是返回 **前 5 行** 数据。

### 2. **选取中间任意几行**

#### 语法一：`SELECT 数据列 FROM 数据表 LIMIT m - n OFFSET n`

- **LIMIT m - n**：表示查询从第 n 行到第 m 行之间的数据，`m - n` 代表查询的行数。
- **OFFSET n**：表示跳过前 n 行数据，从第 n + 1 行开始返回结果。
- 例如，如果 `n=5` 和 `m=10`，这条 SQL 查询会从第 5 行（即跳过前 5 行）开始，返回接下来的 5 行（第 6 到第 10 行）。

#### 语法二：`SELECT 数据列 FROM 数据表 OFFSET n ROWS FETCH NEXT m - n ROWS ONLY`

- **OFFSET n ROWS**：跳过前 n 行数据。
- **FETCH NEXT m - n ROWS ONLY**：返回接下来 m - n 行数据。
- 这两者的组合实现了从第 n 行开始，返回从第 n 到第 m 行的数据。
- 这个语法是 SQL 标准语法，主要在一些数据库如 SQL Server 或 PostgreSQL 中使用，允许更细粒度的控制查询的偏移量和行数。

### 总结：

- `LIMIT` 和 `OFFSET` 用于控制查询的结果返回行数和位置。
- `LIMIT` 后跟一个数字表示返回前几行，`OFFSET` 用于指定跳过多少行。
- 使用 `FETCH NEXT` 可以更加明确地控制要获取多少行数据。

你通常会看到这两种语法在不同数据库系统中使用，第一种是 MySQL 和 SQLite 等常见的数据库中常用的形式，第二种（使用 `OFFSET` 和 `FETCH`）更接近 SQL 标准。

## 2.字符通配

### 字符匹配

一般形式为：

列名 [NOT ] LIKE

匹配串中可包含如下四种通配符：
_：匹配任意一个字符；
%：匹配0个或多个字符；
[ ]：匹配[ ]中的任意一个字符(若要比较的字符是连续的，则可以用连字符“-”表 达 )；
[ ^  ]：不匹配[ ]中的任意一个字符。

例23．查询学生表中姓‘张’的学生的详细信息。

```
SELECT` `* ``FROM` `学生表 ``WHERE` `姓名 ``LIKE` `‘张%’
```

例24．查询姓“张”且名字是3个字的学生姓名。

```
SELECT` `* ``FROM` `学生表 ``WHERE` `姓名 ``LIKE` `'张__’
```

如果把姓名列的类型改为nchar(20)，在SQL Server 2012中执行没有结果。原因是姓名列的类型是char(20)，当姓名少于20个汉字时，系统在存储这些数据时自动在后边补空格，空格作为一个字符，也参加LIKE的比较。可以用rtrim()去掉右空格。

```
SELECT` `* ``FROM` `学生表 ``WHERE` `rtrim(姓名) ``LIKE` `'张__'
```

例25.查询学生表中姓‘张’、姓‘李’和姓‘刘’的学生的情况。

```
SELECT` `* ``FROM` `学生表 ``WHERE` `姓名 ``LIKE` `'[张李刘]%’
```

例26.查询学生表表中名字的第2个字为“小”或“大”的学生的姓名和学号。

```
SELECT` `姓名,学号 ``FROM` `学生表 ``WHERE` `姓名 ``LIKE` `'_[小大]%'
```

例27.查询学生表中所有不姓“刘”的学生。

```
SELECT` `姓名 ``FROM` `学生 ``WHERE` `姓名 ``NOT` `LIKE` `'刘%’
```

例28.从学生表表中查询学号的最后一位不是2、3、5的学生信息。

```
SELECT` `* ``FROM` `学生表 ``WHERE` `学号 ``LIKE` `'%[^235]'
```

## 3.使用聚合函数汇总数据

SQL提供的统计函数有：
COUNT( * )：统计表中元组个数；
COUNT([DISTINCT] <列名>)：统计本列列值个数；
SUM( <列名> )：计算列值总和；
AVG( <列名> )：计算列值平均值；
MAX( <列名> )：求列值最大值；
MIN( <列名> )： 求列值最小值。
上述函数中除COUNT( * )外，其他函数在计算过程中均忽略NULL值。

ROUND 函数用于把数值字段舍入为指定的小数位数。

**计算男生人数以及平均GPA**

```mysql
select count(gender) as male_num,round(avg(gpa),``1``) as avg_gpa``from user_profile``where gender=``'male'``;
```

order by 默认升序 加DESC为降序





# 手撕  池组件  智能指针  stl容器等  网络编程  锁 各种锁乐观读写等  运算符重载  设计模式  lambda 大小根堆 排序

# 手撕题

## 1.三个线程交替打印abc

```c++
#include<iostream>
#include<thread>
#include<condition_variable>
#include<mutex>
using namespace std;
mutex mtx;
condition_variable cv;
int flag = 0;
void PrintABC(char ch,int order){
    while(1){
        unique_lock<mutex> lock(mtx);
    cv.wait(lock,[order]{return flag ==  order;});
    cout<<ch;
    flag = (flag+1)%3;
    cv.notify_all();
    }
}
int main(){
    thread t1(PrintABC,'A',0);
    thread t2(PrintABC,'B',1);
    thread t3(PrintABC,'C',2);
    t1.join();
    t2.join();
    t3.join();
    return 0;
}
```



## 2.设计一个定时任务调用类

### 单次添加一个任务

```c++
#include <iostream>
#include <thread>
#include <functional>
#include <atomic>
#include <chrono>

class TimerTask {
public:
    TimerTask() : running(false) {}

    // 启动定时任务
    void start(std::function<void()> task, int interval_ms) {
        if (running.load()) return; // 避免重复启动
        running.store(true);
        worker = std::thread([this, task, interval_ms]() {
            while (running.load()) {
                auto nextRun = std::chrono::steady_clock::now() + std::chrono::milliseconds(interval_ms);
                task();  // 执行任务
                std::this_thread::sleep_until(nextRun); // 等待到下次执行时间点
            }
        });
    }

    // 停止任务
    void stop() {
        running.store(false);
        if (worker.joinable()) {
            worker.join();
        }
    }

    ~TimerTask() {
        stop();  // 确保退出时释放资源
    }

private:
    std::thread worker;
    std::atomic<bool> running;
};

void exampleTask() {
    std::cout << "定时任务执行: " << std::chrono::system_clock::now().time_since_epoch().count() << std::endl;
}

int main() {
    TimerTask timer;
    timer.start(exampleTask, 1000); // 每 1000ms 执行一次任务

    std::this_thread::sleep_for(std::chrono::seconds(5)); // 让主线程等一会
    timer.stop(); // 停止任务

    return 0;
}

```

### 可同时添加多个任务

```c++
#include <iostream>
#include <thread>
#include <functional>
#include <unordered_map>
#include <atomic>
#include <chrono>
#include <mutex>

class TimerScheduler {
public:
    TimerScheduler() : running(true) {}

    // 添加定时任务，返回任务 ID
    int addTask(std::function<void()> task, int interval_ms) {
        std::lock_guard<std::mutex> lock(mtx);
        int taskId = nextTaskId++;
        workers[taskId] = std::thread([this, taskId, task, interval_ms]() {
            while (running.load() && taskRunning[taskId]) {
                auto nextRun = std::chrono::steady_clock::now() + std::chrono::milliseconds(interval_ms);
                task();  // 执行任务
                std::this_thread::sleep_until(nextRun); // 等待到下次执行时间点
            }
        });
        taskRunning[taskId] = true;
        return taskId;
    }

    // 移除定时任务
    void removeTask(int taskId) {
        std::lock_guard<std::mutex> lock(mtx);
        if (workers.find(taskId) != workers.end()) {
            taskRunning[taskId] = false;
            if (workers[taskId].joinable()) {
                workers[taskId].join();
            }
            workers.erase(taskId);
            taskRunning.erase(taskId);
        }
    }

    // 关闭所有任务
    void stopAll() {
        running.store(false);
        for (auto& [taskId, thread] : workers) {
            taskRunning[taskId] = false;
            if (thread.joinable()) {
                thread.join();
            }
        }
        workers.clear();
        taskRunning.clear();
    }

    ~TimerScheduler() {
        stopAll();  // 确保退出时清理所有线程
    }

private:
    std::unordered_map<int, std::thread> workers;
    std::unordered_map<int, std::atomic<bool>> taskRunning;
    std::atomic<bool> running;
    std::mutex mtx;
    int nextTaskId = 0;
};

// 示例任务
void taskA() {
    std::cout << "Task A running at " << std::chrono::system_clock::now().time_since_epoch().count() << std::endl;
}

void taskB() {
    std::cout << "Task B running at " << std::chrono::system_clock::now().time_since_epoch().count() << std::endl;
}

int main() {
    TimerScheduler scheduler;
    
    int taskA_id = scheduler.addTask(taskA, 1000); // 每 1 秒执行一次
    int taskB_id = scheduler.addTask(taskB, 2000); // 每 2 秒执行一次

    std::this_thread::sleep_for(std::chrono::seconds(6)); // 让任务跑一段时间

    scheduler.removeTask(taskA_id); // 移除 Task A
    std::this_thread::sleep_for(std::chrono::seconds(4)); // 让 Task B 继续执行

    scheduler.stopAll(); // 停止所有任务
    return 0;
}

```



## 3.c++模拟rpc调用

## 4.c++模拟服务发现

## 5.c++模拟负载均衡

## 6.手写shared_ptr

```c++
#include <iostream>
#include <atomic>

template <typename T>
class SharedPtr {
private:
    T* ptr;  // 资源指针
    std::atomic<int>* ref_count;  // 引用计数

public:
    // ✅ 构造函数
    explicit SharedPtr(T* p = nullptr) : ptr(p), ref_count(new std::atomic<int>(p ? 1 : 0)) {}

    // ✅ 拷贝构造（增加引用计数）
    SharedPtr(const SharedPtr& other) : ptr(other.ptr), ref_count(other.ref_count) {
        if (ptr) (*ref_count)++;
    }

    // ✅ 移动构造（转移所有权）
    SharedPtr(SharedPtr&& other) noexcept : ptr(other.ptr), ref_count(other.ref_count) {
        other.ptr = nullptr;
        other.ref_count = nullptr;
    }

    // ✅ 赋值运算符（拷贝）
    SharedPtr& operator=(const SharedPtr& other) {
        if (this != &other) {
            release();
            ptr = other.ptr;
            ref_count = other.ref_count;
            if (ptr) (*ref_count)++;
        }
        return *this;
    }

    // ✅ 赋值运算符（移动）
    SharedPtr& operator=(SharedPtr&& other) noexcept {
        if (this != &other) {
            release();
            ptr = other.ptr;
            ref_count = other.ref_count;
            other.ptr = nullptr;
            other.ref_count = nullptr;
        }
        return *this;
    }

    // ✅ 析构函数（减少引用计数，必要时释放资源）
    ~SharedPtr() {
        release();
    }

    // ✅ 释放资源（减少引用计数）
    void release() {
        if (ptr && --(*ref_count) == 0) {
            delete ptr;
            delete ref_count;
        }
        ptr = nullptr;
        ref_count = nullptr;
    }

    // ✅ 获取原始指针
    T* get() const { return ptr; }

    // ✅ 解引用
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    // ✅ 获取引用计数
    int use_count() const { return ptr ? *ref_count : 0; }

    // ✅ 判断是否唯一
    bool unique() const { return use_count() == 1; }

    // ✅ 显式重置
    void reset(T* p = nullptr) {
        release();
        ptr = p;
        ref_count = new std::atomic<int>(p ? 1 : 0);
    }
};

// ✅ 辅助函数 `make_shared`
template <typename T, typename... Args>
SharedPtr<T> make_shared(Args&&... args) {
    return SharedPtr<T>(new T(std::forward<Args>(args)...));
}

```

## 7.手写堆排序或堆操作(大小根堆)

## 8.手写各种排序  主要快速排序  拓扑排序？？

![](C:\Users\86138\Desktop\wangzhan\df717a867a097be37b3184de1a8dbe5a.png)

### 冒泡排序 O n^2

```c++
for(int i = 0;i < length - 1;i++){
    for(int j = 0;j < length - i - 1;j++){
        if(s[j] > s[j + 1]) swap(s[j],s[j + 1]);
    }
}
```

### 插入排序 O n^2

```c++
int i,j;
for(i = 1;i < length;i++){
    for(j = i;j > 0;j--){
        if(s[j] < s[j - 1]) swap(s[j],s[j - 1]);
        else break;
    }
}
```

### 选择排序 O n^2

```c++
int min;
for(int i = 0;i < length;i++){
    min = i;
    for(int j = i + 1;j < length;j++){
        if(s[min] > s[j]) min = j;
    }
    swap(s[min],s[i]);
}
```

### 归并排序 O nlogn

```c++
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) { // 递归终止条件：当 left >= right 时，子数组大小为 1
        int mid = left + (right - left) / 2; // 计算中间位置
        
        mergeSort(arr, left, mid); // 递归排序左半部分
        mergeSort(arr, mid + 1, right); // 递归排序右半部分
        
        merge(arr, left, mid, right); // 合并两个有序子数组
    }
}
void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;  // 左子数组的长度
    int n2 = right - mid;      // 右子数组的长度
    
    vector<int> leftArr(n1), rightArr(n2); // 创建两个临时数组
    
    for (int i = 0; i < n1; i++) leftArr[i] = arr[left + i]; // 复制左半部分
    for (int i = 0; i < n2; i++) rightArr[i] = arr[mid + 1 + i]; // 复制右半部分
    
    int i = 0, j = 0, k = left; // i 负责遍历 leftArr，j 负责遍历 rightArr，k 负责写入 arr
    
    // 合并两个子数组
    while (i < n1 && j < n2) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k++] = leftArr[i++]; // 取较小值放入 arr
        } else {
            arr[k++] = rightArr[j++];
        }
    }
    
    // 若左子数组有剩余元素，继续写入 arr
    while (i < n1) arr[k++] = leftArr[i++];
    // 若右子数组有剩余元素，继续写入 arr
    while (j < n2) arr[k++] = rightArr[j++];
}

```

### 希尔排序 O nlogn ~ O n^2

```c++
// 希尔排序
void shellSort(vector<int>& arr) {
    int n = arr.size();
    
    // 选择初始间隔 gap，通常从 n/2 开始，每次缩小一半
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 从 gap 开始，对每个元素进行插入排序
        for (int i = gap; i < n; i++) {
            int temp = arr[i]; // 记录当前待插入的元素
            int j = i;
            
            // 在子序列中执行插入排序（倒序查找插入位置）
            while (j >= gap && arr[j - gap] > temp) {
                arr[j] = arr[j - gap]; // 向右移动元素
                j -= gap;
            }
            arr[j] = temp; // 插入元素
        }
    }
}
```

### 快速排序 O nlogn (三路快排？)

（1）选定一个基准元素
（2）从右往左找到比基准元素小的元素
（3）从左往右找到比基准元素大的元素
（4）交换左右找到的两个元素的位置
（5）重复上面（2）（3）（4）步，直至左右两个元素相遇。

```c++
// 快速排序 - 分区函数（Hoare 分区法）
int partition(vector<int>& arr, int low, int high) {
    /*
    int randomIndex = low + rand() % (high - low + 1); // 生成 low 到 high 之间的随机索引
    swap(arr[low], arr[randomIndex]); // 将随机选取的基准值交换到最左边
    */
    int pivot = arr[low]; // 选择最左边的元素作为基准
    int left = low, right = high;

    while (left < right) {
        while (left < right && arr[right] >= pivot) right--; // 从右向左找小于 pivot 的数
        while (left < right && arr[left] <= pivot) left++;  // 从左向右找大于 pivot 的数

        if (left < right) swap(arr[left], arr[right]); // 交换位置
    }

    swap(arr[low], arr[left]); // 基准值放到最终位置
    return left; // 返回基准的最终位置
}

// 递归实现快速排序
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high); // 分区
        quickSort(arr, low, pivotIndex - 1);  // 递归左半部分
        quickSort(arr, pivotIndex + 1, high); // 递归右半部分
    }
}

//另一种写法
void quickSort(vector<int>& nums,int low,int high){
        if(low >= high) return;
        int flag = nums[low];
        int left = low;
        int right = high;
        while(left < right){
            while(left < right && nums[right] >= flag) right--;
            while(left < right && nums[left] <= flag) left++;
            if(left < right) swap(nums[left],nums[right]);
        }
        swap(nums[low],nums[left]);
        quickSort(nums,low,left - 1);
        quickSort(nums,left + 1,high);
    }
```

### 堆排序 O nlogn

**总结:可以替换堆顶元素直接向下调整，可以把堆顶元素和最后一个元素交换再向下调整，建堆要从第一个非叶子节点开始一直到根**

**应用：**

选出**最大K个数**，则建**小堆**。

选出**最小K个数**，则建**大堆**。

方法一：利用priority_queue结构实现堆排序
可以借助C++中的priority_queue容器实现堆排序，默认为大根堆，具体代码如下：

```c++
#include <queue>
using namespace std;

void heapSort(vector<int>& nums){
    priority_queue<int, vector<int>> q;
    for(int i = 0; i < nums.size(); ++i){
        q.push(nums[i]);
    }
    for(int i = nums.size() - 1; i >= 0; --i){
        nums[i] = q.top(); q.pop();
    }
}
```

时间复杂度为O(NlogN)，该方法中使用额外容器实现堆结构，空间复杂度为O(N)。

方法二：借助堆结构性质实现空间复杂度为O(1)的堆排序

在 **堆排序** 中，我们主要用的是 **向下调整（Heapify Down）**，具体体现在两个步骤：

1. 建堆（Heapify）
   - 从最后一个非叶子节点开始，**向下调整**，确保整个数组成为合法的堆。
   - 这里是 **批量建堆的优化方法**，时间复杂度为 O(n)（而不是 O(nlog⁡n)）。
2. 排序
   - 把堆顶（最大值）和数组末尾元素交换，缩小堆的范围，然后 **对新的堆顶进行向下调整**，恢复堆的性质。
   - 这个过程的时间复杂度为 O(nlog⁡n)

```c++
// 调整以 index 为根节点的子堆，n 是堆的大小
void heapify(vector<int>& nums, int index, int n) {
    int left = index * 2 + 1; // 左子节点索引
    int right = left + 1;    // 右子节点索引
    int largest = index;     // 假设当前节点为最大值

    // 如果左子节点存在且比当前最大值大，更新最大值索引
    if (left < n && nums[left] > nums[largest]) {
        largest = left;
    }
    // 如果右子节点存在且比当前最大值大，更新最大值索引
    if (right < n && nums[right] > nums[largest]) {
        largest = right;
    }

    // 如果最大值不是当前节点，交换并递归调整
    if (largest != index) {
        swap(nums[index], nums[largest]);
        heapify(nums, largest, n); // 递归调整
    }
}
/*
void heapify(vector<int>& nums, int index, int n) {
    while (true) {
        int left = index * 2 + 1;
        int right = left + 1;
        int largest = index;

        if (left < n && nums[left] > nums[largest]) {
            largest = left;
        }
        if (right < n && nums[right] > nums[largest]) {
            largest = right;
        }
        if (largest == index) break;  // 若已是最大堆，则结束循环

        swap(nums[index], nums[largest]);
        index = largest;  // 继续向下调整
    }
}

*/
// 堆排序
void heapSort(vector<int>& nums) {
    int n = nums.size();

    // 建堆，从最后一个非叶子节点开始调整
    for (int i = n / 2 - 1; i >= 0; --i) {
        heapify(nums, i, n);
    }

    // 排序，将堆顶元素移到数组末尾，并调整剩余堆
    for (int i = n - 1; i > 0; --i) {
        swap(nums[0], nums[i]);    // 堆顶和末尾元素交换
        heapify(nums, 0, i);       // 调整剩余堆
    }
}

```

### 桶排序 

```c++
// 桶排序函数
template <typename T>
void bucketSort(vector<T>& arr, int bucketSize = 5) {
    if (arr.empty()) return;

    // 找到数组的最大值和最小值
    T minValue = *min_element(arr.begin(), arr.end());
    T maxValue = *max_element(arr.begin(), arr.end());

    // 计算桶的数量
    int bucketCount = (maxValue - minValue) / bucketSize + 1;
    vector<vector<T>> buckets(bucketCount);

    // 将元素分配到不同的桶中
    for (const auto& num : arr) {
        int bucketIndex = (num - minValue) / bucketSize;
        buckets[bucketIndex].push_back(num);
    }

    // 对每个桶进行排序，并合并结果
    arr.clear();
    for (auto& bucket : buckets) {
        sort(bucket.begin(), bucket.end()); // 桶内排序
        arr.insert(arr.end(), bucket.begin(), bucket.end()); // 连接所有桶
    }
}
```

**1. 最佳情况（Best Case, O(n))**

- 如果输入数据已经均匀分布在各个桶中，每个桶中的元素数量很少（理想情况下最多 1 个）。
- 这样，插入桶的操作是 **O(n)**，每个桶内的排序（如果只有 1 个元素）是 **O(1)**，最后合并结果也是 **O(n)**。
- 总体时间复杂度为 **O(n)**。

**2. 平均情况（Average Case, O(n + k log k))**

- 设 **n** 是元素数量，**k** 是桶的数量。
- **元素分配到桶** 需要 **O(n)**。
- **每个桶内部排序**，如果桶内元素的数量为 `m`，那么使用 `std::sort()` 的时间复杂度为 **O(m log m)**。
- 由于桶的总数约为 `k ≈ n / bucketSize`，每个桶的元素大约 `m ≈ bucketSize`。
- 设定合理的 `bucketSize`，可以使得 `m log m` 维持在常数级别 **O(1)**。
- 整体复杂度可近似为 **O(n + k log k)**，对于 **k 远小于 n 的情况**，则复杂度趋近 **O(n)**。

**3. 最坏情况（Worst Case, O(n²))**

- 如果所有元素都被分配到同一个桶（极端情况下所有元素相同），桶排序会退化为**对整个数组进行排序**，如快速排序 **O(n log n)**。
- 但如果选择了**不合适的桶大小**，某些桶内元素分布极度不均匀，则可能导致某些桶内排序变得很慢，接近 **O(n²)**。

## 9.手写lambda表达式

## 10.运算符重载

## 11.两种单例模式实现(llfc)(懒汉 饿汉 双重检查锁)

```c++
#include <memory>
#include <mutex>
#include <iostream>
using namespace std;
template <typename T>
class Singleton {
protected:
    Singleton() = default;
    Singleton(const Singleton<T>&) = delete;
    Singleton& operator=(const Singleton<T>& st) = delete;

    static std::shared_ptr<T> _instance;
public:
    static std::shared_ptr<T> GetInstance() {
        static std::once_flag s_flag;
        std::call_once(s_flag, [&]() {
            _instance = shared_ptr<T>(new T);
            });

        return _instance;
    }
    void PrintAddress() {
        std::cout << _instance.get() << endl;
    }
    ~Singleton() {
        std::cout << "this is singleton destruct" << std::endl;
    }
};

template <typename T>
std::shared_ptr<T> Singleton<T>::_instance = nullptr;
```



## 12.生产者消费者

```c++
#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>

std::queue<int> buffer;  // 存储产品的缓冲区
const int maxBufferSize = 10;  // 缓冲区的最大容量
std::mutex mtx;  // 用于保护缓冲区的互斥锁
std::condition_variable notFull;  // 当缓冲区未满时通知生产者
std::condition_variable notEmpty;  // 当缓冲区不为空时通知消费者

// 生产者函数
void producer() {
    int producedItem = 0;
    while (true) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));  // 模拟生产耗时
        std::unique_lock<std::mutex> lock(mtx);

        // 如果缓冲区已满，则等待
        notFull.wait(lock, []() { return buffer.size() < maxBufferSize; });

        buffer.push(producedItem);
        std::cout << "生产者生产了产品: " << producedItem << std::endl;
        producedItem++;

        // 唤醒一个消费者线程
        notEmpty.notify_one();
    }
}

// 消费者函数
void consumer() {
    while (true) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1500));  // 模拟消费耗时
        std::unique_lock<std::mutex> lock(mtx);

        // 如果缓冲区为空，则等待
        notEmpty.wait(lock, []() { return !buffer.empty(); });

        int consumedItem = buffer.front();
        buffer.pop();
        std::cout << "消费者消费了产品: " << consumedItem << std::endl;

        // 唤醒一个生产者线程
        notFull.notify_one();
    }
}

int main() {
    std::thread producerThread(producer);
    std::thread consumerThread(consumer);

    producerThread.join();
    consumerThread.join();

    return 0;
}

```



## 13.手写string

```c++
#include <cstring>  // 为了使用 strlen 和 strcpy

class String {
public:
    // 默认构造函数
    String();
    String(const char* s);
    String(const String& s);
    String& operator=(const String& s);
    ~String();

private:
    char* m_data;
    size_t length;
};

String::String() : m_data(nullptr), length(0) {
}

String::String(const char* s) {
    if (s) {  // 检查传入的字符串是否为 nullptr
        length = strlen(s);
        m_data = new char[length + 1];  // +1 为了存储字符串的结束符 '\0'
        strcpy(m_data, s);
    } else {
        m_data = nullptr;
        length = 0;
    }
}

String::String(const String& s) {
    if (s.m_data) {  // 确保源字符串非空
        length = s.length;
        m_data = new char[length + 1];
        strcpy(m_data, s.m_data);
    } else {
        m_data = nullptr;
        length = 0;
    }
}

String& String::operator=(const String& s) {
    if (this != &s) {  // 防止自我赋值
        delete[] m_data;  // 释放旧内存

        if (s.m_data) {  // 如果源对象有数据
            length = s.length;
            m_data = new char[length + 1];
            strcpy(m_data, s.m_data);
        } else {
            m_data = nullptr;
            length = 0;
        }
    }
    return *this;
}

String::~String() {
    delete[] m_data;  // 释放内存
}

```

## 14.手写内存池 线程池



## 15.手写栈 队列 链表 等数据结构 无锁队列？

## 16.手写死锁

下面是一个简单的 C++ 死锁实例，其中两个线程分别持有两个锁，并相互等待对方释放锁，从而导致死锁：

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mutex1;
std::mutex mutex2;

void thread1() {
    std::lock_guard<std::mutex> lock1(mutex1);
    std::cout << "Thread 1 locked mutex1\n";
    
    // 模拟工作
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    std::lock_guard<std::mutex> lock2(mutex2);
    std::cout << "Thread 1 locked mutex2\n";
}

void thread2() {
    std::lock_guard<std::mutex> lock2(mutex2);
    std::cout << "Thread 2 locked mutex2\n";
    
    // 模拟工作
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    std::lock_guard<std::mutex> lock1(mutex1);
    std::cout << "Thread 2 locked mutex1\n";
}

int main() {
    std::thread t1(thread1);
    std::thread t2(thread2);

    t1.join();
    t2.join();

    return 0;
}
```

### 说明：

1. `thread1` 先锁定 `mutex1`，然后尝试锁定 `mutex2`。
2. `thread2` 先锁定 `mutex2`，然后尝试锁定 `mutex1`。
3. 如果 `thread1` 锁定了 `mutex1` 且在等待 `mutex2`，而 `thread2` 锁定了 `mutex2` 且在等待 `mutex1`，就会发生死锁，两个线程永远都无法释放锁。

### 输出：

- `Thread 1 locked mutex1`
- `Thread 2 locked mutex2`
- 由于死锁，接下来两个线程都无法继续执行，程序会停在 `lock_guard` 处。

## 17.手写memove

## 18.迪杰斯特拉 图论等

## 20.手撕线程安全的链表 栈 队列
