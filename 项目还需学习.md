gyodurrtvlxddihd

**整个项目是怎么设计的（从需求到技术选型）、如果从单体改成微服务打算怎么改**

**知道这个项目为什么这样做，这样做有什么好处？性能瓶颈点点发生在什么？怎么去拓展**

**用户之间的消息传输是使用的什么**

## **项目注重怎么优化的** 项目上线

**GateServer 用TCP直接做长连接通信 或 使用WebSocket**

**mysql表怎么设计的**

**nginx正反向代理**

# 目前该看

# 1.rpc    rpc协议有几层       grpc主要问题底层原理  问什么快  用什么传输与通信协议  跨语言  grpc与http区别好处  grpc安全性 负载均衡 重试策略？ grpc异步使用方式手写  proto2和proto3区别  grpc和其他rpc比较  结合项目

# http长连接 短连接  底层

# 2.ASIO  非常重要  主要问题底层原理 同步和异步io  io模型  数据处理的调度方案 和其他网络库比较  哪些场景适合  如何实现跨平台  结合项目

# 3.protobuf和json使用对比 缺点与优点 编码解码 怎么压缩 那些可以压缩(int?浮点？)   protobuf哪些结构好  对数据传输有帮助  解析时处理错误 优化性能 序列化反序列化底层原理  大端小端概念与判断  底层数据格式(二进制格式 字段标识 长度前缀等等) 数据结构发送变动如何维护  还有哪些序列化协议 如何解析前端传来的json   json解析器   结合项目



# 项目常问问题

# 阻塞怎么办  性能测试 压力测试 负载测试qps

































# 1.奇异递归模板模式（CRTP)

[Design Patterns With C++（八）CRTP（上） - 知乎](https://zhuanlan.zhihu.com/p/142407249)

# 2.单例模式



```cpp
#include <memory>
#include <mutex>
#include <iostream>
using namespace std;
template <typename T>
class Singleton {
protected:
    Singleton() = default;
    Singleton(const Singleton<T>&) = delete;
    Singleton& operator=(const Singleton<T>& st) = delete;

    static std::shared_ptr<T> _instance;
public:
    static std::shared_ptr<T> GetInstance() {
        static std::once_flag s_flag;
        std::call_once(s_flag, [&]() {
            //继承模版单例类的子类的构造会设置为private，make_shared无法访问私有的构造函数
            _instance = shared_ptr<T>(new T);
            });

        return _instance;
    }
    void PrintAddress() {
        std::cout << _instance.get() << endl;
    }
    ~Singleton() {
        std::cout << "this is singleton destruct" << std::endl;
    }
};

template <typename T>
std::shared_ptr<T> Singleton<T>::_instance = nullptr;
```

# 3.http请求方式get post ......

HTTP请求方式（也称为HTTP方法）是HTTP协议中用于定义客户端与服务器交互行为的一组标准方法。以下是常用的HTTP请求方式及其用途：

------

### 1. **GET**

- 功能：
  - 请求指定资源，并从服务器获取数据。
- 特点：
  - 数据通过URL传递（作为查询字符串）。
  - **不应有副作用**，即请求资源不会改变服务器的状态（属于幂等操作）。
  - 请求的数据大小受限于URL长度。
- 应用场景：
  - 获取网页、文件、图像等资源。
  - 通过URL查询参数获取数据（如搜索引擎查询）。

------

### 2. **POST**

- 功能：
  - 向服务器提交数据，用于创建或处理资源。
- 特点：
  - 数据包含在请求体中，传输数据量较大。
  - 通常用于有副作用的操作（如添加数据）。
  - **不幂等**，即多次相同的请求可能导致不同结果。
- 应用场景：
  - 提交表单数据。
  - 上传文件。
  - 发送JSON或XML等格式的数据。

------

### 3. **PUT**

- 功能：
  - 向服务器上传数据，用于**创建**或**更新**资源。
- 特点：
  - 数据包含在请求体中。
  - **幂等**：多次相同请求的结果一致。
- 应用场景：
  - 替换某个资源的全部内容。
  - 用于更新服务器资源的状态或内容。

------

### 4. **PATCH**

- 功能：
  - 对服务器上的资源进行部分更新。
- 特点：
  - 请求体中包含需要更新的部分内容。
  - **不一定幂等**：具体看实现，如果每次请求的结果相同则为幂等。
- 应用场景：
  - 更新资源的某些字段或局部内容。

------

### 5. **DELETE**

- 功能：
  - 请求服务器删除指定资源。
- 特点：
  - **幂等**：删除相同资源多次，最终状态一致（资源不存在）。
- 应用场景：
  - 删除用户信息、文件、数据库记录等。

------

### 6. **HEAD**

- 功能：
  - 类似于GET，但只请求资源的头部信息，不返回具体内容。
- 特点：
  - 通常用于检查资源是否存在或获取资源的元信息（如大小、修改时间）。
  - 不会影响服务器的状态（无副作用）。
- 应用场景：
  - 检查资源的可用性。
  - 获取文件的元信息（如`Content-Length`）。

------

### 7. **OPTIONS**

- 功能：
  - 请求服务器返回支持的HTTP方法列表。
- 特点：
  - 用于跨域请求时检查服务器是否允许指定操作（CORS中的预检请求）。
  - 不改变服务器的状态。
- 应用场景：
  - 检测某资源的可用操作。
  - CORS跨域请求的预检。

------

### 8. **TRACE**

- 功能：
  - 用于诊断和调试，将请求在服务器上的所有操作原样返回给客户端。
- 特点：
  - 通常用于测试HTTP请求的路径。
  - 安全性较低，可能会暴露敏感信息，因此不常使用。
- 应用场景：
  - HTTP请求的调试。

------

### 9. **CONNECT**

- 功能：
  - 建立到服务器的隧道连接（通常用于SSL/TLS加密的HTTPS）。
- 特点：
  - 一般用于代理服务器，建立一个中转通道。
- 应用场景：
  - 通过代理服务器访问HTTPS网站。

------

### **总结**

| **方法**    | **幂等性** | **请求体** | **常用场景**       |
| ----------- | ---------- | ---------- | ------------------ |
| **GET**     | 是         | 无         | 获取数据           |
| **POST**    | 否         | 有         | 提交数据、创建资源 |
| **PUT**     | 是         | 有         | 替换资源           |
| **PATCH**   | 否         | 有         | 部分更新资源       |
| **DELETE**  | 是         | 无         | 删除资源           |
| **HEAD**    | 是         | 无         | 获取元信息         |
| **OPTIONS** | 是         | 无         | 检测支持的方法     |
| **TRACE**   | 否         | 无         | HTTP请求调试       |
| **CONNECT** | 否         | 有         | 建立隧道连接       |

------

**注意**

- GET 和 POST 是最常用的请求方法。
- PUT、PATCH 和 DELETE 在实际使用中，可能需要后端明确支持（某些服务器或框架需要额外配置）。

## get和post区别(看csdn)

# 4.QT实现http

# 5.QT信号和槽

# 6.防止对象析构 共享应用技术

它是一个异步的发送，发送完了之后呢？这个。调用完post之后呢，并不能马上收到对方的回包。

哎，它会QT给我们生成了一个reply的这样一个实例。这个reply我们后期呢，要自动的手动的去回收。然后呢？

我们什么时候能收到它的回包？不确定是通过一个lambda的表达式。告诉我们。这个lambda表达式呢，我们又担心在处理这个lambda表达式的过程中呢。

这个之前已经把这个http manager呢给干掉了。所以我们捕获的是一个self。那想捕获self呢？它是一个智能指针，就需要通过this呢？

生成智能指针，就通过这种方式呢？生成的智能指针和之前管理类似的智能指针呢？达到共享应用技术的一个目的，要想用这个函数呢。

那我们。又给大家介绍了要使用这样一个基类，那么这个基类它的模板类型传递的实实例呢？也是这个http manager。这个也相当于其递归模板的一次使用。

```cpp
void HttpMgr::PostHttpReq(QUrl url, QJsonObject json, ReqId req_id, Modules mod)
{
    //创建一个HTTP POST请求，并设置请求头和请求体
    QByteArray data = QJsonDocument(json).toJson();
    //通过url构造请求
    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setHeader(QNetworkRequest::ContentLengthHeader, QByteArray::number(data.length()));
    //发送请求，并处理响应, 获取自己的智能指针，构造伪闭包并增加智能指针引用计数
    auto self = shared_from_this();
    QNetworkReply * reply = _manager.post(request, data);
    //设置信号和槽等待发送完成
    QObject::connect(reply, &QNetworkReply::finished, [reply, self, req_id, mod](){
        //处理错误的情况
        if(reply->error() != QNetworkReply::NoError){
            qDebug() << reply->errorString();
            //发送信号通知完成
            emit self->sig_http_finish(req_id, "", ErrorCodes::ERR_NETWORK, mod);
            reply->deleteLater();
            return;
        }

        //无错误则读回请求
        QString res = reply->readAll();

        //发送信号通知完成
        emit self->sig_http_finish(req_id, res, ErrorCodes::SUCCESS,mod);
        reply->deleteLater();
        return;
    });
}

```

# 7.asio底层

# 8.try catch

# 9.json和protobuf

## protobuf使用

# 10.粘包问题	

# 11.通信过程  http？(短连接？)   tcp长连接？   websocket？

# 12.服务端主动关闭客户端引发timewait？

# 13.前置声明解决互引用

# 14. boost::urls::encode

# 15.移植到linux下

```cmake
cmake_minimum_required(VERSION 3.10)

# 项目信息
project(GateServer)

# 指定 C++ 标准
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# 添加 Boost 库
find_package(Boost REQUIRED)
if(Boost_FOUND)
    include_directories(${Boost_INCLUDE_DIRS})
endif()

# 添加 jsoncpp 库
find_package(jsoncpp REQUIRED)
if(jsoncpp_FOUND)
    include_directories(${jsoncpp_INCLUDE_DIRS})
endif()

# 源文件列表
set(SOURCES
    GateServer.cpp
    CServer.cpp
    HttpConnection.cpp
    LogicSystem.cpp
)

# 头文件目录
include_directories(${CMAKE_SOURCE_DIR})

# 生成可执行文件
add_executable(GateServer ${SOURCES})

# 链接库
target_link_libraries(GateServer 
    pthread
    ${Boost_LIBRARIES}
    jsoncpp
)

```



### `std::string` 和 `boost::basic_string_view` 不兼容

Boost 中的 `basic_string_view` 和 `std::string` 并不能直接赋值，必须显式地进行转换。

- 如果 `uri` 是 `boost::basic_string_view` 类型，需显式转换为 `std::string`：

```
_get_url = std::string(uri);
```

- 如果需要截取 `uri` 的子字符串，可使用以下代码：

```
_get_url = std::string(uri.substr(0, query_pos));
```

这将从 `boost::basic_string_view` 转换为 `std::string`。

# **16.先把所有copy完，最后再细致学习每个小节

# 完成后梳理   

# 文档不全

# 总结   

# 写出代码框架逻辑结构

# 自己重写一点代码  

# 费曼学习法写博客

# 全部移植到linux下，利用docker

# **17.ASIO和其他网络库对比

# 18.rpc原理及应用

# 19.函数参数 *   &      在调用时参数怎么写

  如void a（int *a,int &b);

### 调用时的写法

#### 对于指针参数 `int *p`

1. 必须传递一个有效的指针。
2. 如果需要修改原变量的值，可以传递变量的地址。

示例：

```
cpp复制代码int x = 5;
a(&x, r);  // 将变量 x 的地址传入
```

#### 对于引用参数 `int &r`

1. 必须传递一个变量（不能是常量或表达式）。
2. 引用是直接绑定到实参变量的，因此可以直接写变量名。

示例：

```
cpp复制代码int y = 5;
a(&x, y);  // 传递变量 y，本身被直接修改
```

# 20.第八节grpc的使用？

# 21.第九节nodejs改为c++/go?

# 22.线程安全问题？

我们的get serve呢，实际上是用BS的去实现的，这样一个网络库http的，这样一个服务。htp这个服务大家知道，它实际上是面向的，是一个无状态的，也就是说多个连接连过来的时候可能。会有多个底层是多个线程去触发的，那么它对于线程来说呢，是不安全的，对吧？http我们的回调，实际上我们是在这里看到的。即便我们通过的是一个线程，

去在上层是一个线程，但是底层呢，可能是多个线程。那我们先看一下。那么其实还好，因为我们这个大家看我们只创建了这样一个服务跑，在这样一个主线程里。那么，它所有的回调呢？其实都是在通过主线程的这样一个啊lc的，这样一个服务去回调的，实际上它是一个单线程。而如果后期呢，我们把这个http这个服务呢，我们给它创建很多个这样一个lc跑在不同的线程。

来提升它的一个并发能力的情况下，那么它的回调我们看一下它完成了这样一个。呃，回掉。比如说在s ever里，我们有个start。start这里用的这个lc，它的回调是这样一个连接它接收连接的时候呢，可能会呃处于不同的这样一个。呃，线程里当然我们可以让接收连接呢，绑定在一个线程，但是我们处理connection的时候呢，可能这里呢，我们就要去。

呃，搞多个。搞这样多个的，这这个IOC了，那么跑在多个线程里，如果可htp connection跑在多个线程里的时候。那么，它的回调就不是线程安全的。不是线程安全的情况下，那如果我们的它来调用我们的logic的话。比如说我们处理请求调用我们的logic。处理pose的请求的时候。在上面走，它又调到了我们jr PC的这样一个连接。那如果jr PC的这个连接。

哎，它被多个线程同时访问的话，那就会出现线程安全问题，那么为了解决这种问题呢，我们可以引入一个连接池的概念。我们会初始化n个连接，连接到jr PC服务里。然后呢？每个线程呢？去取自己的一个链接，用完了之后呢？再还回来。另外，我们这个http呢，只有一个IOC服务呢。

显得有一些担保，我们尽可能的把接收连接跟处理连接呢分开。那么，接收连接呢？我们还用这个lc，而当我们处理连接的时候呢？我们可以启动多个lc。跑在不同的县城里。那么这样呢，我们http的服务呢，就是一个多线程的了。那么，能够解决一些。高并发的这样一个访问。嗯，

# 23. 线程池

任务无顺序，不强关联，适合线程池

![image-20241127191524955](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20241127191524955.png)

```cpp
#ifndef __THREAD_POOL_H__
#define __THREAD_POOL_H__

#include <atomic>
#include <condition_variable>
#include <future>
#include <iostream>
#include <mutex>
#include <queue>
#include <thread>
#include <vector>

class ThreadPool  {
public:
    ThreadPool(const ThreadPool&) = delete;
    ThreadPool&        operator=(const ThreadPool&) = delete;

    static ThreadPool& instance() {
        static ThreadPool ins;
        return ins;
    }

    using Task = std::packaged_task<void()>;


    ~ThreadPool() {
        stop();
    }

    template <class F, class... Args>
    auto commit(F&& f, Args&&... args) -> std::future<decltype(f(args...))> {
        using RetType = decltype(f(args...));
        if (stop_.load())
            return std::future<RetType>{};

        auto task = std::make_shared<std::packaged_task<RetType()>>(
            std::bind(std::forward<F>(f), std::forward<Args>(args)...));

        std::future<RetType> ret = task->get_future();
        {
            std::lock_guard<std::mutex> cv_mt(cv_mt_);
            tasks_.emplace([task] { (*task)(); });
        }
        cv_lock_.notify_one();
        return ret;
    }

    int idleThreadCount() {
        return thread_num_;
    }

private:
    ThreadPool(unsigned int num = 5)
        : stop_(false) {
            {
                if (num < 1)
                    thread_num_ = 1;
                else
                    thread_num_ = num;
            }
            start();
    }
    void start() {
        for (int i = 0; i < thread_num_; ++i) {
            pool_.emplace_back([this]() {
                while (!this->stop_.load()) {
                    Task task;
                    {
                        std::unique_lock<std::mutex> cv_mt(cv_mt_);
                        this->cv_lock_.wait(cv_mt, [this] {
                            return this->stop_.load() || !this->tasks_.empty();
                        });
                        if (this->tasks_.empty())
                            return;

                        task = std::move(this->tasks_.front());
                        this->tasks_.pop();
                    }
                    this->thread_num_--;
                    task();
                    this->thread_num_++;
                }
            });
        }
    }
    void stop() {
        stop_.store(true);
        cv_lock_.notify_all();
        for (auto& td : pool_) {
            if (td.joinable()) {
                std::cout << "join thread " << td.get_id() << std::endl;
                td.join();
            }
        }
    }

private:
    std::mutex               cv_mt_;
    std::condition_variable  cv_lock_;
    std::atomic_bool         stop_;
    std::atomic_int          thread_num_;
    std::queue<Task>         tasks_;
    std::vector<std::thread> pool_;
};

#endif  // !__THREAD_POOL_H__
```

# 24.提升gateserver并发，改为多线程

# 25.项目如何保证线程安全

# **26.redis编程  使用c++实现

# **27.grpc编程

# 28.mysql不暴露端口？利用docker?

# 29.简单流程![image-20241216225915200](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20241216225915200.png)

# 30.当输入含有重复的用户名或邮箱中的一项，必须修改这两项才能注册？bug

# 31.

![image-20241218143512722](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20241218143512722.png)

![image-20241218143654586](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20241218143654586.png)

# 32.集群  微服务 区别  优缺点

# 33.自己设计一个数据库连接池  连接池的好处